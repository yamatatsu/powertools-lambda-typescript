{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Do not use this library in production AWS Lambda Powertools for TypeScript is currently released as a beta developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release . Do not use this library for production workloads. AWS Lambda Powertools for TypeScript provides a suite of utilities for AWS Lambda functions running on the Node.js runtime, to ease the adoption of best practices such as tracing, structured logging, custom metrics, and more. Tenets \u00b6 Core utilities such as Tracer, Logger, Metrics, and Event Handler will be available across all Lambda Powertools runtimes. Additional utilities are subjective to each language ecosystem and customer demand. AWS Lambda only . We optimise for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported. Eases the adoption of best practices . The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional. Keep it lean . Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time. We strive for backwards compatibility . New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined. We work backwards from the community . We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs) Progressive . Utilities are designed to be incrementally adoptable for customers at any stage of their Serverless journey. They follow language idioms and their community\u2019s common practices. Features \u00b6 Utility Description Tracer Utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and a middleware to enrich log items with key details of the Lambda context Metrics Custom Metrics created asynchronously via CloudWatch Embedded Metric Format (EMF) Installation \u00b6 The AWS Lambda Powertools for TypeScript utilities (which from here will be referred as Powertools) follow a modular approach, similar to the official AWS SDK v3 for JavaScript . Each TypeScript utility is installed as standalone NPM package. Installation guide for the Tracer utility Installation guide for the Logger utility Installation guide for the Metrics utility Environment variables \u00b6 Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_ENABLED Explicitly disables tracing Tracer true POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracer true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracer true POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS Captures HTTP(s) requests as segments. Tracer true POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logger false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logger 0 POWERTOOLS_LOG_DEDUPLICATION_DISABLED Disables log deduplication filter protection to use Pytest Live Log feature Logger false LOG_LEVEL Sets logging level Logger INFO Examples \u00b6 CDK SAM Tracer Logger Metrics Credits \u00b6 Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools . Connect \u00b6 AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com","title":"Homepage"},{"location":"#tenets","text":"Core utilities such as Tracer, Logger, Metrics, and Event Handler will be available across all Lambda Powertools runtimes. Additional utilities are subjective to each language ecosystem and customer demand. AWS Lambda only . We optimise for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported. Eases the adoption of best practices . The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional. Keep it lean . Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time. We strive for backwards compatibility . New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined. We work backwards from the community . We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs) Progressive . Utilities are designed to be incrementally adoptable for customers at any stage of their Serverless journey. They follow language idioms and their community\u2019s common practices.","title":"Tenets"},{"location":"#features","text":"Utility Description Tracer Utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and a middleware to enrich log items with key details of the Lambda context Metrics Custom Metrics created asynchronously via CloudWatch Embedded Metric Format (EMF)","title":"Features"},{"location":"#installation","text":"The AWS Lambda Powertools for TypeScript utilities (which from here will be referred as Powertools) follow a modular approach, similar to the official AWS SDK v3 for JavaScript . Each TypeScript utility is installed as standalone NPM package. Installation guide for the Tracer utility Installation guide for the Logger utility Installation guide for the Metrics utility","title":"Installation"},{"location":"#environment-variables","text":"Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_ENABLED Explicitly disables tracing Tracer true POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracer true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracer true POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS Captures HTTP(s) requests as segments. Tracer true POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logger false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logger 0 POWERTOOLS_LOG_DEDUPLICATION_DISABLED Disables log deduplication filter protection to use Pytest Live Log feature Logger false LOG_LEVEL Sets logging level Logger INFO","title":"Environment variables"},{"location":"#examples","text":"CDK SAM Tracer Logger Metrics","title":"Examples"},{"location":"#credits","text":"Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools .","title":"Credits"},{"location":"#connect","text":"AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com","title":"Connect"},{"location":"changelog/","text":"Change Log \u00b6 All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines. 0.9.1 (2022-05-24) \u00b6 Bug Fixes \u00b6 logger: enable logging of arbitrary objects ( #883 ) ( 5d34854 ) 0.9.0 (2022-05-16) \u00b6 Bug Fixes \u00b6 added back fetch-depth: 0 ( #812 ) ( 494c742 ) logger: add xray_trace_id to every log ( #776 ) ( 11af21a ) reintroduce token while checking out ( #848 ) ( cabef3e ) removed token from remaining actions ( #805 ) ( 4fd9ecb ) Features \u00b6 examples: added sam example to workflows ( #849 ) ( 93f1c7b ) 0.8.1 (2022-04-14) \u00b6 Bug Fixes \u00b6 logger: change logging to use stdout ( #748 ) ( 0781a47 ) 0.8.0 (2022-04-08) \u00b6 Features \u00b6 added captureHTTPsRequest feature ( #677 ) ( 5a36723 ) 0.7.2 (2022-04-01) \u00b6 Note: Version bump only for package aws-lambda-powertools-typescript 0.7.1 (2022-03-17) \u00b6 Bug Fixes \u00b6 logger: enable sequential invocation in e2e test ( #658 ) ( 800424b ) logger: fix handling of additional log keys ( #614 ) ( 8aab299 ) tracer, metrics: use polling instead of fixed wait in e2e tests ( #654 ) ( 6d4ab75 ) 0.7.0 (2022-03-08) \u00b6 Features \u00b6 logger: adopted Utility class & updated unit tests ( #550 ) ( 48f3487 ) metrics: adopted Utility class ( #548 ) ( 672e6a8 ) tracer: adopted Utility class & updated unit tests ( #549 ) ( 3769a69 ) 0.6.0 (2022-02-17) \u00b6 Bug Fixes \u00b6 logger: fix logger attribute merging ( #535 ) ( 8180be1 ) Features \u00b6 commons: centralize cold start heuristic ( #547 ) ( 4e4091f ) logger: add e2e tests for logger ( #529 ) ( e736b65 ) 0.5.1 (2022-02-09) \u00b6 Bug Fixes \u00b6 tracer: properly return DynamoDB.DocumentClient ( #528 ) ( 3559e7b ) Reverts \u00b6 Revert \"build(deps-dev): bump aws-cdk from 1.139.0 to 1.143.0 (#532)\" (#544) ( e96c9ba ), closes #532 #544 Revert \"build(deps-dev): bump @aws-cdk/aws-lambda-nodejs from 1.139.0 to 1.143.0 (#531)\" (#545) ( 7dffbd8 ), closes #531 #545 0.5.0 (2022-01-26) \u00b6 Bug Fixes \u00b6 examples: fix errors in logger and metrics examples ( #509 ) ( c19b47c ) logger|metrics: properly return decorated class ( #489 ) ( 014c5bd ) Features \u00b6 Add codespaces/gitpod support ( #485 ) ( ed6f258 ) all: make @middy/core optional ( #511 ) ( 1107f96 ) tracer: add support for capturing DynamoDB DocumentClient ( #450 ) ( 621ae50 ) 0.4.0 (2022-01-20) \u00b6 Features \u00b6 logger: JSDOCS support ( #491 ) ( cd2c2d9 ) 0.3.3 (2022-01-17) \u00b6 Bug Fixes \u00b6 lerna version not publishing all packages ( #480 ) ( 0cabc3f ) 0.3.2 (2022-01-17) \u00b6 Bug Fixes \u00b6 export LogFormatter + update docs ( #479 ) ( 7f91566 ) updated CDK examples to remove old references & improve comments ( #439 ) ( 4cdaaea ) 0.3.1 (2022-01-14) \u00b6 Bug Fixes \u00b6 all: fix latest release broken by change of npm pack result on common ( #470 ) ( 2c3df93 ), closes #417 0.3.0 (2022-01-14) \u00b6 Bug Fixes \u00b6 build: Fix linting issue and add linting to the pre-push hook ( #440 ) ( e7bc53c ) build: Update contributing.md and fix npm ci ( #417 ) ( 279ad98 ), closes #415 #415 metrics: Rename purgeStoredMetrics() function usage in CDK example ( #424 ) ( 02f0eae ) tracer: avoid throwing errors in manual instrumentation when running outside of AWS Lambda ( #442 ) ( fd02acb ) Features \u00b6 all: Update to examples use released version (0.2.0) ( #405 ) ( d5e0620 ) 0.2.0 (2022-01-05) \u00b6 Features \u00b6 tracer: beta release (#91 (https://github.com/awslabs/aws-lambda-powertools-python/issues/91)) logger: beta release (#24 (https://github.com/awslabs/aws-lambda-powertools-python/issues/24)) metrics: beta release (#25 (https://github.com/awslabs/aws-lambda-powertools-python/issues/25)) Contributions \u00b6 chore(ci): auto-label PR on semantic title (#403) by @heitorlessa fix: documentation generation on on-release.yml workflow (#368) by @ijemmy fix: Remove publishing doc on develop version and fix missing leading 0 in version (#356) by @ijemmy feat: generate new version of doc for each release (#355) by @ijemmy chore(cicd): cdk examples and e2e tests for metrics (#326) by @flochaz fix(cicd): skip ci on bump commit (#339) by @flochaz chore(cicd): fix publish (#336) by @flochaz chore(cicd): Add release workflow (#260) by @flochaz chore(commons): Create a common package (#314) by @flochaz feat: Auto publish docs to version \"develop\" (#269) by @ijemmy fix(metrics): publish metrics even if handler throw (#249) by @flochaz chore: fix linting (#247) by @flochaz chore(all): npm libraries bump and breaking changes fixes (#215) by @saragerion chore: Enable auto-merge for dependabot PRs (#169) by @dreamorosi feat: add metrics (#102) by @alan-churley chore: Add commit hooks for testing and linting (#149) by @bahrmichael chore: Removed assignees from issue templates (#146) by @dreamorosi chore: Disabled auto-assign-issues integration (#144) by @dreamorosi feat: Adding sample automation for PR (#121) by @alan-churley test(logger): add unit tests with most important scenarios and features (#52) by @saragerion chore: increase version of WS dependancy (#71) by @alan-churley chore: dependancies upgrade (#70) by @alan-churley build(github-actions): fix YAML of closed issues message (#23) by @saragerion improv: repository documentation, metadata, github actions, dot files (#17) by @saragerion refactor(logger): overall improvements - DX, examples, business logic (#16) by @saragerion chore: updating path for coverage (#12) by @alan-churley feat(logger): add context decorator functionality (#13) by @saragerion test(all): add mock Lambda events payloads generated by other AWS services (#10) by @saragerion feat(logger): basic logger logic (#9) by @saragerion revert: Remove CodeQL analysis (#2) by @alan-churley feat(metrics): rename method purgeStoredMetrics to publishStoredMetrics (#377) by @flochaz fix(metrics): use same naming for serviceName (#401) by @flochaz feat(commons): update types to have optional callback (#394) by @flochaz feat(metrics): logMetrics middleware (#338) by @saragerion chore(tracer): quality of life improvements (#337) by @dreamorosi feat(tracer): middy middleware (#324) by @dreamorosi feat(logger): middy middleware (#313) by @saragerion chore(ALL): fix packaging (#316) by @flochaz feat: add tracer (#107) by @dreamorosi feat(logger): documentation, examples, business logic changes (#293) by @saragerion feat(metric): bring feature parity between decorator and utility function (#291) by @flochaz docs(all): make docs more coherent (#387) by @dreamorosi docs(logger): improve mkdocs and examples of sample rate feature (#389) by @saragerion docs(all): clarifications & fixes (#370) by @dreamorosi chore(tracer): cdk examples + e2e tests (#347) by @dreamorosi docs(all): getting started section, beta release warning (#351) by @saragerion chore(docs): Tracer docs (#274) by @dreamorosi chore(docs): Add credits section to README (#305) by @dreamorosi chore(metrics): Add typeDoc (#285) by @flochaz feat(logger): documentation, examples, business logic changes (#293) by @saragerion chore(metrics): github page doc (#284) by @flochaz feat: generate api docs (#277) by @ijemmy docs: base documentation (#250) by @dreamorosi docs: updating readme and package.json to work with lerna (#11) by @alan-churley fix(metrics): Support multiple addMetric() call with the same metric name (#390) by @ijemmy fix(logger): display correct log level in cloudwatch (#386) by @saragerion fix(metrics): expose logMetrics middleware (#380) by @flochaz chore: change license (#117) by @dreamorosi chore: don't bump version for merge to main (#404) by @flochaz feat(ALL): Use optional callback LambdaInterface for decorator (#397) by @flochaz chore(ci): add release drafter workflow (#382) by @heitorlessa build(deps): bump e2e dependencies metrics (#371) by @dreamorosi build(deps-dev): bump @aws-cdk/aws-lambda from 1.136.0 to 1.137.0 (#340) by @dependabot chore(commons): Remove eslint from commons pkg (#352) by @dreamorosi build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#335) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 17.0.0 (#325) by @dependabot build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#318) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#317) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.5 (#310) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.88 (#312) by @dependabot build(deps-dev): bump typescript from 4.5.2 to 4.5.4 (#311) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.7.0 (#308) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.7.0 (#309) by @dependabot build(deps): bump aws-xray-sdk-core from 3.3.3 to 3.3.4 (#307) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#297) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.87 (#299) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#300) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#298) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#296) by @dependabot build(deps-dev): bump typescript from 4.5.2 to 4.5.3 (#287) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#288) by @dependabot build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#283) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#272) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#271) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#270) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#273) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#268) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#267) by @dependabot build(deps-dev): bump eslint from 8.3.0 to 8.4.1 (#266) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#265) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.0 (#264) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#263) by @dependabot build(deps): bump romeovs/lcov-reporter-action from 0.2.21 to 0.3.1 (#261) by @dependabot build(deps-dev): bump @types/jest from 27.0.2 to 27.0.3 (#258) by @dependabot build(deps-dev): bump @types/node from 16.11.6 to 16.11.11 (#257) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.33.0 to 5.5.0 (#256) by @dependabot build(deps-dev): bump @types/lodash from 4.14.175 to 4.14.177 (#255) by @dependabot build(deps): bump @types/aws-lambda from 8.10.84 to 8.10.85 (#252) by @dependabot build(deps-dev): bump jest from 27.3.1 to 27.4.3 (#251) by @dependabot build(deps-dev): bump husky from 7.0.2 to 7.0.4 (#243) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.33.0 to 5.5.0 (#253) by @dependabot build(deps-dev): bump eslint from 8.1.0 to 8.3.0 (#254) by @dependabot build(deps-dev): bump typescript from 4.4.3 to 4.5.2 (#245) by @dependabot build(deps-dev): bump ts-node from 10.3.0 to 10.4.0 (#242) by @dependabot build(deps-dev): bump ts-jest from 27.0.5 to 27.0.7 (#234) by @dependabot build(deps-dev): bump @commitlint/cli from 13.2.1 to 15.0.0 (#244) by @dependabot build(deps-dev): bump jest from 27.2.5 to 27.3.1 (#235) by @dependabot build(deps-dev): bump eslint from 7.32.0 to 8.1.0 (#239) by @dependabot build(deps-dev): bump @types/node from 16.10.3 to 16.11.6 (#240) by @dependabot build(deps-dev): bump ts-node from 10.2.1 to 10.3.0 (#226) by @dependabot build(deps-dev): bump jest from 27.2.4 to 27.2.5 (#225) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.83 to 8.10.84 (#223) by @dependabot build(deps-dev): bump @commitlint/cli from 13.2.0 to 13.2.1 (#222) by @dependabot build(deps-dev): bump jest from 27.2.2 to 27.2.4 (#217) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.32.0 to 4.33.0 (#219) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.32.0 to 4.33.0 (#220) by @dependabot build(deps-dev): bump @types/node from 16.10.1 to 16.10.3 (#221) by @dependabot build(deps-dev): bump jest from 27.0.6 to 27.2.2 (#212) by @dependabot build(deps-dev): bump ts-jest from 27.0.4 to 27.0.5 (#181) by @dependabot build(deps): bump actions/github-script from 4.1 to 5 (#211) by @dependabot build(deps-dev): bump typescript from 4.3.5 to 4.4.3 (#199) by @dependabot build(deps-dev): bump @types/node from 16.9.6 to 16.10.1 (#213) by @dependabot build(deps-dev): bump @types/lodash from 4.14.173 to 4.14.174 (#214) by @dependabot build(deps-dev): bump @types/node from 16.9.4 to 16.9.6 (#210) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.30.0 to 4.31.2 (#209) by @dependabot build(deps-dev): bump @types/jest from 27.0.1 to 27.0.2 (#208) by @dependabot build(deps-dev): bump @types/node from 16.9.2 to 16.9.4 (#205) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.31.1 to 4.31.2 (#206) by @dependabot build(deps-dev): bump @types/node from 16.9.1 to 16.9.2 (#204) by @dependabot build(deps-dev): bump @types/lodash from 4.14.172 to 4.14.173 (#203) by @dependabot build(deps-dev): bump @types/node from 16.7.2 to 16.9.1 (#202) by @dependabot build(deps-dev): bump husky from 7.0.1 to 7.0.2 (#191) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.2 to 4.31.1 (#200) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.2 to 4.30.0 (#194) by @dependabot build(deps-dev): bump @types/node from 16.6.2 to 16.7.2 (#190) by @dependabot build(deps): bump actions/github-script from 4.0.2 to 4.1 (#187) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.82 to 8.10.83 (#186) by @dependabot build(deps): bump actions/github-script from 3.1.0 to 4.0.2 (#179) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.1 to 4.29.2 (#180) by @dependabot build(deps-dev): bump @types/node from 16.6.1 to 16.6.2 (#184) by @dependabot build(deps-dev): bump ts-node from 10.2.0 to 10.2.1 (#183) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.1 to 4.29.2 (#182) by @dependabot build(deps-dev): bump @types/jest from 27.0.0 to 27.0.1 (#177) by @dependabot build(deps-dev): bump @types/node from 16.6.0 to 16.6.1 (#176) by @dependabot build(deps-dev): bump @types/node from 16.4.13 to 16.6.0 (#174) by @dependabot build(deps-dev): bump @commitlint/cli from 12.1.4 to 13.1.0 (#172) by @dependabot build(deps-dev): bump @types/jest from 26.0.24 to 27.0.0 (#171) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.81 to 8.10.82 (#170) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.0 to 4.29.1 (#167) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.0 to 4.29.1 (#166) by @dependabot improv: Use lodash.merge & lodash.clonedeed instead of full lodash in Logger (#159) by @dreamorosi build(deps-dev): bump ts-node from 10.1.0 to 10.2.0 (#164) by @dependabot build(deps-dev): bump @types/node from 16.4.10 to 16.4.13 (#162) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.5 to 4.29.0 (#156) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.5 to 4.29.0 (#157) by @dependabot build(deps-dev): bump @types/lodash from 4.14.171 to 4.14.172 (#158) by @dependabot build(deps-dev): bump eslint from 7.31.0 to 7.32.0 (#155) by @dependabot build(deps-dev): bump @types/node from 16.4.7 to 16.4.10 (#154) by @dependabot build(deps-dev): bump @types/node from 16.4.6 to 16.4.7 (#150) by @dependabot build(deps-dev): bump @types/node from 16.4.5 to 16.4.6 (#148) by @dependabot build(deps-dev): bump @types/node from 16.4.3 to 16.4.5 (#145) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.4 to 4.28.5 (#138) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.4 to 4.28.5 (#137) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.80 to 8.10.81 (#135) by @dependabot build(deps-dev): bump @types/node from 16.4.1 to 16.4.3 (#134) by @dependabot build(deps-dev): bump @types/node from 16.4.0 to 16.4.1 (#132) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.79 to 8.10.80 (#128) by @dependabot build(deps-dev): bump ts-jest from 27.0.3 to 27.0.4 (#127) by @dependabot build(deps-dev): bump @types/node from 16.3.3 to 16.4.0 (#124) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.3 to 4.28.4 (#122) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.3 to 4.28.4 (#123) by @dependabot build(deps-dev): bump eslint from 7.30.0 to 7.31.0 (#118) by @dependabot build(deps-dev): bump @types/node from 16.3.2 to 16.3.3 (#119) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.78 to 8.10.79 (#114) by @dependabot build(deps-dev): bump @types/node from 16.0.0 to 16.3.2 (#113) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.2 to 4.28.3 (#112) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.2 to 4.28.3 (#111) by @dependabot build(deps-dev): bump ts-node from 10.0.0 to 10.1.0 (#110) by @dependabot build(deps-dev): bump @types/lodash from 4.14.170 to 4.14.171 (#105) by @dependabot build(deps-dev): bump @types/jest from 26.0.23 to 26.0.24 (#104) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.77 to 8.10.78 (#103) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.1 to 4.28.2 (#100) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.1 to 4.28.2 (#101) by @dependabot build(deps-dev): bump @types/node from 15.14.0 to 16.0.0 (#98) by @dependabot build(deps-dev): bump eslint from 7.29.0 to 7.30.0 (#99) by @dependabot build(deps-dev): bump typescript from 4.3.4 to 4.3.5 (#97) by @dependabot build(deps-dev): bump @types/node from 15.12.3 to 15.14.0 (#96) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.27.0 to 4.28.1 (#94) by @dependabot build(deps-dev): bump eslint from 7.28.0 to 7.29.0 (#86) by @dependabot build(deps-dev): bump @types/node from 15.12.3 to 15.12.5 (#92) by @dependabot build(deps-dev): bump jest from 27.0.4 to 27.0.6 (#93) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.27.0 to 4.28.1 (#95) by @dependabot build(deps-dev): bump typescript from 4.3.2 to 4.3.4 (#84) by @dependabot build(deps-dev): bump @types/node from 15.12.2 to 15.12.3 (#85) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.26.1 to 4.27.0 (#81) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.1 to 4.27.0 (#82) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.26.0 to 4.26.1 (#80) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.0 to 4.26.1 (#78) by @dependabot build(deps-dev): bump @types/node from 15.12.1 to 15.12.2 (#79) by @dependabot build(deps-dev): bump jest from 26.6.3 to 27.0.4 (#73) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.25.0 to 4.26.0 (#69) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.25.0 to 4.26.0 (#68) by @dependabot build(deps-dev): bump typescript from 4.2.4 to 4.3.2 (#66) by @dependabot build(deps-dev): bump @types/node from 15.3.1 to 15.6.1 (#61) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.24.0 to 4.25.0 (#62) by @dependabot build(deps-dev): bump @types/lodash from 4.14.169 to 4.14.170 (#60) by @dependabot build(deps-dev): bump ts-node from 9.1.1 to 10.0.0 (#58) by @dependabot build(deps-dev): bump eslint from 7.26.0 to 7.27.0 (#57) by @dependabot build(deps-dev): bump @types/node from 15.3.0 to 15.3.1 (#56) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.23.0 to 4.24.0 (#55) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.23.0 to 4.24.0 (#54) by @dependabot build(deps-dev): bump @types/node from 15.0.3 to 15.3.0 (#53) by @dependabot build(deps-dev): bump @types/node from 14.14.37 to 15.0.3 (#50) by @dependabot build(deps-dev): bump lerna from 3.22.1 to 4.0.0 (#29) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.21.0 to 4.22.0 (#37) by @dependabot build(deps-dev): bump eslint from 7.23.0 to 7.24.0 (#35) by @dependabot build(deps): bump romeovs/lcov-reporter-action from v0.2.11 to v0.2.21 (#34) by @dependabot build(deps-dev): bump @commitlint/cli from 11.0.0 to 12.1.1 (#33) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.72 to 8.10.75 (#32) by @dependabot build(deps-dev): bump @types/node from 14.14.20 to 14.14.37 (#31) by @dependabot build(deps-dev): bump husky from 4.3.7 to 6.0.0 (#30) by @dependabot build(deps-dev): bump typescript from 4.1.3 to 4.2.4 (#28) by @dependabot build(deps-dev): bump ts-jest from 26.4.4 to 26.5.4 (#27) by @dependabot build(deps-dev): bump eslint from 7.17.0 to 7.23.0 (#21) by @dependabot build(deps-dev): bump @types/jest from 26.0.20 to 26.0.22 (#22) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.13.0 to 4.21.0 (#20) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.13.0 to 4.21.0 (#18) by @dependabot build(deps-dev): bump @commitlint/config-conventional from 11.0.0 to 12.1.1 (#19) by @dependabot docs: updating readme and package.json to work with lerna (#11) by @alan-churley chore: lerna downstream dependancy security issues (#15) by @alan-churley build(deps): bump ini from 1.3.5 to 1.3.8 (#5) by @dependabot build(deps): bump ini from 1.3.5 to 1.3.8 in /packages/logging (#4) by @dependabot build(deps): bump ini from 1.3.5 to 1.3.8 in /docs (#3) by @dependabot Contributor List: \u00b6 @alan-churley, @bahrmichael, @dreamorosi, @flochaz, @heitorlessa, @ijemmy and @saragerion","title":"Changelog"},{"location":"changelog/#change-log","text":"All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.","title":"Change Log"},{"location":"changelog/#091-2022-05-24","text":"","title":"0.9.1 (2022-05-24)"},{"location":"changelog/#bug-fixes","text":"logger: enable logging of arbitrary objects ( #883 ) ( 5d34854 )","title":"Bug Fixes"},{"location":"changelog/#090-2022-05-16","text":"","title":"0.9.0 (2022-05-16)"},{"location":"changelog/#bug-fixes_1","text":"added back fetch-depth: 0 ( #812 ) ( 494c742 ) logger: add xray_trace_id to every log ( #776 ) ( 11af21a ) reintroduce token while checking out ( #848 ) ( cabef3e ) removed token from remaining actions ( #805 ) ( 4fd9ecb )","title":"Bug Fixes"},{"location":"changelog/#features","text":"examples: added sam example to workflows ( #849 ) ( 93f1c7b )","title":"Features"},{"location":"changelog/#081-2022-04-14","text":"","title":"0.8.1 (2022-04-14)"},{"location":"changelog/#bug-fixes_2","text":"logger: change logging to use stdout ( #748 ) ( 0781a47 )","title":"Bug Fixes"},{"location":"changelog/#080-2022-04-08","text":"","title":"0.8.0 (2022-04-08)"},{"location":"changelog/#features_1","text":"added captureHTTPsRequest feature ( #677 ) ( 5a36723 )","title":"Features"},{"location":"changelog/#072-2022-04-01","text":"Note: Version bump only for package aws-lambda-powertools-typescript","title":"0.7.2 (2022-04-01)"},{"location":"changelog/#071-2022-03-17","text":"","title":"0.7.1 (2022-03-17)"},{"location":"changelog/#bug-fixes_3","text":"logger: enable sequential invocation in e2e test ( #658 ) ( 800424b ) logger: fix handling of additional log keys ( #614 ) ( 8aab299 ) tracer, metrics: use polling instead of fixed wait in e2e tests ( #654 ) ( 6d4ab75 )","title":"Bug Fixes"},{"location":"changelog/#070-2022-03-08","text":"","title":"0.7.0 (2022-03-08)"},{"location":"changelog/#features_2","text":"logger: adopted Utility class & updated unit tests ( #550 ) ( 48f3487 ) metrics: adopted Utility class ( #548 ) ( 672e6a8 ) tracer: adopted Utility class & updated unit tests ( #549 ) ( 3769a69 )","title":"Features"},{"location":"changelog/#060-2022-02-17","text":"","title":"0.6.0 (2022-02-17)"},{"location":"changelog/#bug-fixes_4","text":"logger: fix logger attribute merging ( #535 ) ( 8180be1 )","title":"Bug Fixes"},{"location":"changelog/#features_3","text":"commons: centralize cold start heuristic ( #547 ) ( 4e4091f ) logger: add e2e tests for logger ( #529 ) ( e736b65 )","title":"Features"},{"location":"changelog/#051-2022-02-09","text":"","title":"0.5.1 (2022-02-09)"},{"location":"changelog/#bug-fixes_5","text":"tracer: properly return DynamoDB.DocumentClient ( #528 ) ( 3559e7b )","title":"Bug Fixes"},{"location":"changelog/#reverts","text":"Revert \"build(deps-dev): bump aws-cdk from 1.139.0 to 1.143.0 (#532)\" (#544) ( e96c9ba ), closes #532 #544 Revert \"build(deps-dev): bump @aws-cdk/aws-lambda-nodejs from 1.139.0 to 1.143.0 (#531)\" (#545) ( 7dffbd8 ), closes #531 #545","title":"Reverts"},{"location":"changelog/#050-2022-01-26","text":"","title":"0.5.0 (2022-01-26)"},{"location":"changelog/#bug-fixes_6","text":"examples: fix errors in logger and metrics examples ( #509 ) ( c19b47c ) logger|metrics: properly return decorated class ( #489 ) ( 014c5bd )","title":"Bug Fixes"},{"location":"changelog/#features_4","text":"Add codespaces/gitpod support ( #485 ) ( ed6f258 ) all: make @middy/core optional ( #511 ) ( 1107f96 ) tracer: add support for capturing DynamoDB DocumentClient ( #450 ) ( 621ae50 )","title":"Features"},{"location":"changelog/#040-2022-01-20","text":"","title":"0.4.0 (2022-01-20)"},{"location":"changelog/#features_5","text":"logger: JSDOCS support ( #491 ) ( cd2c2d9 )","title":"Features"},{"location":"changelog/#033-2022-01-17","text":"","title":"0.3.3 (2022-01-17)"},{"location":"changelog/#bug-fixes_7","text":"lerna version not publishing all packages ( #480 ) ( 0cabc3f )","title":"Bug Fixes"},{"location":"changelog/#032-2022-01-17","text":"","title":"0.3.2 (2022-01-17)"},{"location":"changelog/#bug-fixes_8","text":"export LogFormatter + update docs ( #479 ) ( 7f91566 ) updated CDK examples to remove old references & improve comments ( #439 ) ( 4cdaaea )","title":"Bug Fixes"},{"location":"changelog/#031-2022-01-14","text":"","title":"0.3.1 (2022-01-14)"},{"location":"changelog/#bug-fixes_9","text":"all: fix latest release broken by change of npm pack result on common ( #470 ) ( 2c3df93 ), closes #417","title":"Bug Fixes"},{"location":"changelog/#030-2022-01-14","text":"","title":"0.3.0 (2022-01-14)"},{"location":"changelog/#bug-fixes_10","text":"build: Fix linting issue and add linting to the pre-push hook ( #440 ) ( e7bc53c ) build: Update contributing.md and fix npm ci ( #417 ) ( 279ad98 ), closes #415 #415 metrics: Rename purgeStoredMetrics() function usage in CDK example ( #424 ) ( 02f0eae ) tracer: avoid throwing errors in manual instrumentation when running outside of AWS Lambda ( #442 ) ( fd02acb )","title":"Bug Fixes"},{"location":"changelog/#features_6","text":"all: Update to examples use released version (0.2.0) ( #405 ) ( d5e0620 )","title":"Features"},{"location":"changelog/#020-2022-01-05","text":"","title":"0.2.0 (2022-01-05)"},{"location":"changelog/#features_7","text":"tracer: beta release (#91 (https://github.com/awslabs/aws-lambda-powertools-python/issues/91)) logger: beta release (#24 (https://github.com/awslabs/aws-lambda-powertools-python/issues/24)) metrics: beta release (#25 (https://github.com/awslabs/aws-lambda-powertools-python/issues/25))","title":"Features"},{"location":"changelog/#contributions","text":"chore(ci): auto-label PR on semantic title (#403) by @heitorlessa fix: documentation generation on on-release.yml workflow (#368) by @ijemmy fix: Remove publishing doc on develop version and fix missing leading 0 in version (#356) by @ijemmy feat: generate new version of doc for each release (#355) by @ijemmy chore(cicd): cdk examples and e2e tests for metrics (#326) by @flochaz fix(cicd): skip ci on bump commit (#339) by @flochaz chore(cicd): fix publish (#336) by @flochaz chore(cicd): Add release workflow (#260) by @flochaz chore(commons): Create a common package (#314) by @flochaz feat: Auto publish docs to version \"develop\" (#269) by @ijemmy fix(metrics): publish metrics even if handler throw (#249) by @flochaz chore: fix linting (#247) by @flochaz chore(all): npm libraries bump and breaking changes fixes (#215) by @saragerion chore: Enable auto-merge for dependabot PRs (#169) by @dreamorosi feat: add metrics (#102) by @alan-churley chore: Add commit hooks for testing and linting (#149) by @bahrmichael chore: Removed assignees from issue templates (#146) by @dreamorosi chore: Disabled auto-assign-issues integration (#144) by @dreamorosi feat: Adding sample automation for PR (#121) by @alan-churley test(logger): add unit tests with most important scenarios and features (#52) by @saragerion chore: increase version of WS dependancy (#71) by @alan-churley chore: dependancies upgrade (#70) by @alan-churley build(github-actions): fix YAML of closed issues message (#23) by @saragerion improv: repository documentation, metadata, github actions, dot files (#17) by @saragerion refactor(logger): overall improvements - DX, examples, business logic (#16) by @saragerion chore: updating path for coverage (#12) by @alan-churley feat(logger): add context decorator functionality (#13) by @saragerion test(all): add mock Lambda events payloads generated by other AWS services (#10) by @saragerion feat(logger): basic logger logic (#9) by @saragerion revert: Remove CodeQL analysis (#2) by @alan-churley feat(metrics): rename method purgeStoredMetrics to publishStoredMetrics (#377) by @flochaz fix(metrics): use same naming for serviceName (#401) by @flochaz feat(commons): update types to have optional callback (#394) by @flochaz feat(metrics): logMetrics middleware (#338) by @saragerion chore(tracer): quality of life improvements (#337) by @dreamorosi feat(tracer): middy middleware (#324) by @dreamorosi feat(logger): middy middleware (#313) by @saragerion chore(ALL): fix packaging (#316) by @flochaz feat: add tracer (#107) by @dreamorosi feat(logger): documentation, examples, business logic changes (#293) by @saragerion feat(metric): bring feature parity between decorator and utility function (#291) by @flochaz docs(all): make docs more coherent (#387) by @dreamorosi docs(logger): improve mkdocs and examples of sample rate feature (#389) by @saragerion docs(all): clarifications & fixes (#370) by @dreamorosi chore(tracer): cdk examples + e2e tests (#347) by @dreamorosi docs(all): getting started section, beta release warning (#351) by @saragerion chore(docs): Tracer docs (#274) by @dreamorosi chore(docs): Add credits section to README (#305) by @dreamorosi chore(metrics): Add typeDoc (#285) by @flochaz feat(logger): documentation, examples, business logic changes (#293) by @saragerion chore(metrics): github page doc (#284) by @flochaz feat: generate api docs (#277) by @ijemmy docs: base documentation (#250) by @dreamorosi docs: updating readme and package.json to work with lerna (#11) by @alan-churley fix(metrics): Support multiple addMetric() call with the same metric name (#390) by @ijemmy fix(logger): display correct log level in cloudwatch (#386) by @saragerion fix(metrics): expose logMetrics middleware (#380) by @flochaz chore: change license (#117) by @dreamorosi chore: don't bump version for merge to main (#404) by @flochaz feat(ALL): Use optional callback LambdaInterface for decorator (#397) by @flochaz chore(ci): add release drafter workflow (#382) by @heitorlessa build(deps): bump e2e dependencies metrics (#371) by @dreamorosi build(deps-dev): bump @aws-cdk/aws-lambda from 1.136.0 to 1.137.0 (#340) by @dependabot chore(commons): Remove eslint from commons pkg (#352) by @dreamorosi build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#335) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 17.0.0 (#325) by @dependabot build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#318) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#317) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.5 (#310) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.88 (#312) by @dependabot build(deps-dev): bump typescript from 4.5.2 to 4.5.4 (#311) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.7.0 (#308) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.7.0 (#309) by @dependabot build(deps): bump aws-xray-sdk-core from 3.3.3 to 3.3.4 (#307) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#297) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.87 (#299) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#300) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#298) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#296) by @dependabot build(deps-dev): bump typescript from 4.5.2 to 4.5.3 (#287) by @dependabot build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#288) by @dependabot build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#283) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#272) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#271) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#270) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#273) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#268) by @dependabot build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#267) by @dependabot build(deps-dev): bump eslint from 8.3.0 to 8.4.1 (#266) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#265) by @dependabot build(deps-dev): bump ts-jest from 27.0.7 to 27.1.0 (#264) by @dependabot build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#263) by @dependabot build(deps): bump romeovs/lcov-reporter-action from 0.2.21 to 0.3.1 (#261) by @dependabot build(deps-dev): bump @types/jest from 27.0.2 to 27.0.3 (#258) by @dependabot build(deps-dev): bump @types/node from 16.11.6 to 16.11.11 (#257) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.33.0 to 5.5.0 (#256) by @dependabot build(deps-dev): bump @types/lodash from 4.14.175 to 4.14.177 (#255) by @dependabot build(deps): bump @types/aws-lambda from 8.10.84 to 8.10.85 (#252) by @dependabot build(deps-dev): bump jest from 27.3.1 to 27.4.3 (#251) by @dependabot build(deps-dev): bump husky from 7.0.2 to 7.0.4 (#243) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.33.0 to 5.5.0 (#253) by @dependabot build(deps-dev): bump eslint from 8.1.0 to 8.3.0 (#254) by @dependabot build(deps-dev): bump typescript from 4.4.3 to 4.5.2 (#245) by @dependabot build(deps-dev): bump ts-node from 10.3.0 to 10.4.0 (#242) by @dependabot build(deps-dev): bump ts-jest from 27.0.5 to 27.0.7 (#234) by @dependabot build(deps-dev): bump @commitlint/cli from 13.2.1 to 15.0.0 (#244) by @dependabot build(deps-dev): bump jest from 27.2.5 to 27.3.1 (#235) by @dependabot build(deps-dev): bump eslint from 7.32.0 to 8.1.0 (#239) by @dependabot build(deps-dev): bump @types/node from 16.10.3 to 16.11.6 (#240) by @dependabot build(deps-dev): bump ts-node from 10.2.1 to 10.3.0 (#226) by @dependabot build(deps-dev): bump jest from 27.2.4 to 27.2.5 (#225) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.83 to 8.10.84 (#223) by @dependabot build(deps-dev): bump @commitlint/cli from 13.2.0 to 13.2.1 (#222) by @dependabot build(deps-dev): bump jest from 27.2.2 to 27.2.4 (#217) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.32.0 to 4.33.0 (#219) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.32.0 to 4.33.0 (#220) by @dependabot build(deps-dev): bump @types/node from 16.10.1 to 16.10.3 (#221) by @dependabot build(deps-dev): bump jest from 27.0.6 to 27.2.2 (#212) by @dependabot build(deps-dev): bump ts-jest from 27.0.4 to 27.0.5 (#181) by @dependabot build(deps): bump actions/github-script from 4.1 to 5 (#211) by @dependabot build(deps-dev): bump typescript from 4.3.5 to 4.4.3 (#199) by @dependabot build(deps-dev): bump @types/node from 16.9.6 to 16.10.1 (#213) by @dependabot build(deps-dev): bump @types/lodash from 4.14.173 to 4.14.174 (#214) by @dependabot build(deps-dev): bump @types/node from 16.9.4 to 16.9.6 (#210) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.30.0 to 4.31.2 (#209) by @dependabot build(deps-dev): bump @types/jest from 27.0.1 to 27.0.2 (#208) by @dependabot build(deps-dev): bump @types/node from 16.9.2 to 16.9.4 (#205) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.31.1 to 4.31.2 (#206) by @dependabot build(deps-dev): bump @types/node from 16.9.1 to 16.9.2 (#204) by @dependabot build(deps-dev): bump @types/lodash from 4.14.172 to 4.14.173 (#203) by @dependabot build(deps-dev): bump @types/node from 16.7.2 to 16.9.1 (#202) by @dependabot build(deps-dev): bump husky from 7.0.1 to 7.0.2 (#191) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.2 to 4.31.1 (#200) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.2 to 4.30.0 (#194) by @dependabot build(deps-dev): bump @types/node from 16.6.2 to 16.7.2 (#190) by @dependabot build(deps): bump actions/github-script from 4.0.2 to 4.1 (#187) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.82 to 8.10.83 (#186) by @dependabot build(deps): bump actions/github-script from 3.1.0 to 4.0.2 (#179) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.1 to 4.29.2 (#180) by @dependabot build(deps-dev): bump @types/node from 16.6.1 to 16.6.2 (#184) by @dependabot build(deps-dev): bump ts-node from 10.2.0 to 10.2.1 (#183) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.1 to 4.29.2 (#182) by @dependabot build(deps-dev): bump @types/jest from 27.0.0 to 27.0.1 (#177) by @dependabot build(deps-dev): bump @types/node from 16.6.0 to 16.6.1 (#176) by @dependabot build(deps-dev): bump @types/node from 16.4.13 to 16.6.0 (#174) by @dependabot build(deps-dev): bump @commitlint/cli from 12.1.4 to 13.1.0 (#172) by @dependabot build(deps-dev): bump @types/jest from 26.0.24 to 27.0.0 (#171) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.81 to 8.10.82 (#170) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.0 to 4.29.1 (#167) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.29.0 to 4.29.1 (#166) by @dependabot improv: Use lodash.merge & lodash.clonedeed instead of full lodash in Logger (#159) by @dreamorosi build(deps-dev): bump ts-node from 10.1.0 to 10.2.0 (#164) by @dependabot build(deps-dev): bump @types/node from 16.4.10 to 16.4.13 (#162) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.5 to 4.29.0 (#156) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.5 to 4.29.0 (#157) by @dependabot build(deps-dev): bump @types/lodash from 4.14.171 to 4.14.172 (#158) by @dependabot build(deps-dev): bump eslint from 7.31.0 to 7.32.0 (#155) by @dependabot build(deps-dev): bump @types/node from 16.4.7 to 16.4.10 (#154) by @dependabot build(deps-dev): bump @types/node from 16.4.6 to 16.4.7 (#150) by @dependabot build(deps-dev): bump @types/node from 16.4.5 to 16.4.6 (#148) by @dependabot build(deps-dev): bump @types/node from 16.4.3 to 16.4.5 (#145) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.4 to 4.28.5 (#138) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.4 to 4.28.5 (#137) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.80 to 8.10.81 (#135) by @dependabot build(deps-dev): bump @types/node from 16.4.1 to 16.4.3 (#134) by @dependabot build(deps-dev): bump @types/node from 16.4.0 to 16.4.1 (#132) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.79 to 8.10.80 (#128) by @dependabot build(deps-dev): bump ts-jest from 27.0.3 to 27.0.4 (#127) by @dependabot build(deps-dev): bump @types/node from 16.3.3 to 16.4.0 (#124) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.3 to 4.28.4 (#122) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.3 to 4.28.4 (#123) by @dependabot build(deps-dev): bump eslint from 7.30.0 to 7.31.0 (#118) by @dependabot build(deps-dev): bump @types/node from 16.3.2 to 16.3.3 (#119) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.78 to 8.10.79 (#114) by @dependabot build(deps-dev): bump @types/node from 16.0.0 to 16.3.2 (#113) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.2 to 4.28.3 (#112) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.2 to 4.28.3 (#111) by @dependabot build(deps-dev): bump ts-node from 10.0.0 to 10.1.0 (#110) by @dependabot build(deps-dev): bump @types/lodash from 4.14.170 to 4.14.171 (#105) by @dependabot build(deps-dev): bump @types/jest from 26.0.23 to 26.0.24 (#104) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.77 to 8.10.78 (#103) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.1 to 4.28.2 (#100) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.28.1 to 4.28.2 (#101) by @dependabot build(deps-dev): bump @types/node from 15.14.0 to 16.0.0 (#98) by @dependabot build(deps-dev): bump eslint from 7.29.0 to 7.30.0 (#99) by @dependabot build(deps-dev): bump typescript from 4.3.4 to 4.3.5 (#97) by @dependabot build(deps-dev): bump @types/node from 15.12.3 to 15.14.0 (#96) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.27.0 to 4.28.1 (#94) by @dependabot build(deps-dev): bump eslint from 7.28.0 to 7.29.0 (#86) by @dependabot build(deps-dev): bump @types/node from 15.12.3 to 15.12.5 (#92) by @dependabot build(deps-dev): bump jest from 27.0.4 to 27.0.6 (#93) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.27.0 to 4.28.1 (#95) by @dependabot build(deps-dev): bump typescript from 4.3.2 to 4.3.4 (#84) by @dependabot build(deps-dev): bump @types/node from 15.12.2 to 15.12.3 (#85) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.26.1 to 4.27.0 (#81) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.1 to 4.27.0 (#82) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.26.0 to 4.26.1 (#80) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.0 to 4.26.1 (#78) by @dependabot build(deps-dev): bump @types/node from 15.12.1 to 15.12.2 (#79) by @dependabot build(deps-dev): bump jest from 26.6.3 to 27.0.4 (#73) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.25.0 to 4.26.0 (#69) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.25.0 to 4.26.0 (#68) by @dependabot build(deps-dev): bump typescript from 4.2.4 to 4.3.2 (#66) by @dependabot build(deps-dev): bump @types/node from 15.3.1 to 15.6.1 (#61) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.24.0 to 4.25.0 (#62) by @dependabot build(deps-dev): bump @types/lodash from 4.14.169 to 4.14.170 (#60) by @dependabot build(deps-dev): bump ts-node from 9.1.1 to 10.0.0 (#58) by @dependabot build(deps-dev): bump eslint from 7.26.0 to 7.27.0 (#57) by @dependabot build(deps-dev): bump @types/node from 15.3.0 to 15.3.1 (#56) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.23.0 to 4.24.0 (#55) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.23.0 to 4.24.0 (#54) by @dependabot build(deps-dev): bump @types/node from 15.0.3 to 15.3.0 (#53) by @dependabot build(deps-dev): bump @types/node from 14.14.37 to 15.0.3 (#50) by @dependabot build(deps-dev): bump lerna from 3.22.1 to 4.0.0 (#29) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.21.0 to 4.22.0 (#37) by @dependabot build(deps-dev): bump eslint from 7.23.0 to 7.24.0 (#35) by @dependabot build(deps): bump romeovs/lcov-reporter-action from v0.2.11 to v0.2.21 (#34) by @dependabot build(deps-dev): bump @commitlint/cli from 11.0.0 to 12.1.1 (#33) by @dependabot build(deps-dev): bump @types/aws-lambda from 8.10.72 to 8.10.75 (#32) by @dependabot build(deps-dev): bump @types/node from 14.14.20 to 14.14.37 (#31) by @dependabot build(deps-dev): bump husky from 4.3.7 to 6.0.0 (#30) by @dependabot build(deps-dev): bump typescript from 4.1.3 to 4.2.4 (#28) by @dependabot build(deps-dev): bump ts-jest from 26.4.4 to 26.5.4 (#27) by @dependabot build(deps-dev): bump eslint from 7.17.0 to 7.23.0 (#21) by @dependabot build(deps-dev): bump @types/jest from 26.0.20 to 26.0.22 (#22) by @dependabot build(deps-dev): bump @typescript-eslint/parser from 4.13.0 to 4.21.0 (#20) by @dependabot build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.13.0 to 4.21.0 (#18) by @dependabot build(deps-dev): bump @commitlint/config-conventional from 11.0.0 to 12.1.1 (#19) by @dependabot docs: updating readme and package.json to work with lerna (#11) by @alan-churley chore: lerna downstream dependancy security issues (#15) by @alan-churley build(deps): bump ini from 1.3.5 to 1.3.8 (#5) by @dependabot build(deps): bump ini from 1.3.5 to 1.3.8 in /packages/logging (#4) by @dependabot build(deps): bump ini from 1.3.5 to 1.3.8 in /docs (#3) by @dependabot","title":"Contributions"},{"location":"changelog/#contributor-list","text":"@alan-churley, @bahrmichael, @dreamorosi, @flochaz, @heitorlessa, @ijemmy and @saragerion","title":"Contributor List:"},{"location":"core/logger/","text":"Do not use this library in production AWS Lambda Powertools for TypeScript is currently released as a beta developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release . Do not use this library for production workloads. Logger provides an opinionated logger with output structured as JSON. Key features \u00b6 Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda context when instructed (disabled by default) Log sampling prints all logs for a percentage of invocations (disabled by default) Append additional keys to structured log at any point in time Getting started \u00b6 Installation \u00b6 Install the library in your project: 1 npm install @aws-lambda-powertools/logger Usage \u00b6 The Logger utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Logger can keep track of a cold start and inject the appropriate fields into logs. handler.ts 1 2 3 4 5 6 7 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... }; Utility settings \u00b6 The library requires two settings. You can set them as environment variables, or pass them in the constructor. These settings will be used across all logs emitted: Setting Description Environment variable Constructor parameter Logging level Sets how verbose Logger should be (INFO, by default). Supported values are: DEBUG , INFO , WARN , ERROR LOG_LEVEL logLevel Service name Sets the name of service of which the Lambda function is part of, that will be present across all log statements POWERTOOLS_SERVICE_NAME serviceName For a complete list of supported environment variables, refer to this section . Example using AWS Serverless Application Model (SAM) \u00b6 handler.ts template.yaml 1 2 3 4 5 6 7 8 9 10 import { Logger } from '@aws-lambda-powertools/logger' ; // Logger parameters fetched from the environment variables (see template.yaml tab) const logger = new Logger (); // You can also pass the parameters in the constructor // const logger = new Logger({ // logLevel: 'WARN', // serviceName: 'serverlessAirline' // }); 1 2 3 4 5 6 7 8 9 Resources : ShoppingCartApiFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Environment : Variables : LOG_LEVEL : WARN POWERTOOLS_SERVICE_NAME : serverlessAirline Standard structured keys \u00b6 Your Logger will include the following keys to your structured logging (default log formatter): Key Example Note level : string INFO Logging level set for the Lambda function\"s invocation message : string Query performed to DynamoDB A descriptive, human-readable representation of this log item sampling_rate : float 0.1 When enabled, it prints all the logs of a percentage of invocations, e.g. 10% service : string serverlessAirline A unique name identifier of the service this Lambda function belongs to, by default service_undefined timestamp : string 2011-10-05T14:48:00.000Z Timestamp string in simplified extended ISO format (ISO 8601) xray_trace_id : string 1-5759e988-bd862e3fe1be46a994272793 X-Ray Trace ID. This value is always presented in Lambda environment, whether tracing is enabled or not. Logger will always log this value. error : Object { name: \"Error\", location: \"/my-project/handler.ts:18\", message: \"Unexpected error #1\", stack: \"[stacktrace]\"} Optional - An object containing information about the Error passed to the logger Capturing Lambda context info \u00b6 You can enrich your structured logs with key Lambda context information in multiple ways. This functionality will include the following keys in your structured logs: Key Example cold_start : bool false function_name string shopping-cart-api-lambda-prod-eu-west-1 function_memory_size : number 128 function_arn : string arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1 function_request_id : string c6af9ac6-7b61-11e6-9a41-93e812345678 Manual Middy Middleware Decorator 1 2 3 4 5 6 7 8 9 10 11 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( _event , context ) : Promise < void > => { logger . addContext ( context ); logger . info ( 'This is an INFO log with some context' ); }; Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . 1 2 3 4 5 6 7 8 9 10 11 import { Logger , injectLambdaContext } from '@aws-lambda-powertools/logger' ; import middy from '@middy/core' ; const logger = new Logger (); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { logger . info ( 'This is an INFO log with some context' ); }; export const handler = middy ( lambdaHandler ) . use ( injectLambdaContext ( logger )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Logger } from '@aws-lambda-powertools/logger' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const logger = new Logger (); class Lambda implements LambdaInterface { // Decorate your handler class method @logger . injectLambdaContext () public async handler ( _event : any , _context : any ) : Promise < void > { logger . info ( 'This is an INFO log with some context' ); } } export const myFunction = new Lambda (); export const handler = myFunction . handler ; In each case, the printed log will look like this: Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 { \"cold_start\" : true , \"function_arn\" : \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\" , \"function_memory_size\" : 128 , \"function_request_id\" : \"c6af9ac6-7b61-11e6-9a41-93e812345678\" , \"function_name\" : \"shopping-cart-api-lambda-prod-eu-west-1\" , \"level\" : \"INFO\" , \"message\" : \"This is an INFO log with some context\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:21:08.921Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } Appending persistent additional log keys and values \u00b6 You can append additional persistent keys and values in the logs generated during a Lambda invocation using either mechanism: Via the Logger's appendKeys method, for all log items generated after calling this method Passing them in the Logger's constructor To remove the keys you added, you can use the removeKeys method. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import { Logger } from '@aws-lambda-powertools/logger' ; // Add persistent log keys via the constructor const logger = new Logger ({ persistentLogAttributes : { aws_account_id : '123456789012' , aws_region : 'eu-west-1' , logger : { name : '@aws-lambda-powertools/logger' , version : '0.0.1' , }, extra_key : \"some-value\" } }); // OR add persistent log keys to an existing Logger instance with the appendKeys method: // logger.appendKeys({ // aws_account_id: '123456789012', // aws_region: 'eu-west-1', // logger: { // name: '@aws-lambda-powertools/logger', // version: '0.0.1', // }, // extra_key: \"some-value\" // }); export const handler = async ( _event : any , _context : any ) : Promise < unknown > => { // If you don't want to log the \"extra_key\" attribute in your logs, you can remove it logger . removeKeys ([ \"extra_key\" ]) // This info log will print all extra custom attributes added above // Extra attributes: logger object with name and version of the logger library, awsAccountId, awsRegion logger . info ( 'This is an INFO log' ); logger . info ( 'This is another INFO log' ); return { foo : 'bar' }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:49:58.084Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"aws_account_id\" : \"123456789012\" , \"aws_region\" : \"eu-west-1\" , \"logger\" : { \"name\" : \"@aws-lambda-powertools/logger\" , \"version\" : \"0.0.1\" } } { \"level\" : \"INFO\" , \"message\" : \"This is another INFO log\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:49:58.088Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"aws_account_id\" : \"123456789012\" , \"aws_region\" : \"eu-west-1\" , \"logger\" : { \"name\" : \"@aws-lambda-powertools/logger\" , \"version\" : \"0.0.1\" } } Logger will automatically ignore any key with an undefined value Appending additional data to a single log item \u00b6 You can append additional data to a single log item by passing objects as additional parameters. Pass a simple string for logging it with default key name extra Pass one or multiple objects containing arbitrary data to be logged. Each data object should be placed in an enclosing object as a single property value, you can name this property as you need: { myData: arbitraryObjectToLog } If you already have an object containing a message key and an additional property, you can pass this object directly handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( event : any , _context : any ) : Promise < unknown > => { const myImportantVariable = { foo : 'bar' }; // Log additional data in single log items // As second parameter logger . info ( 'This is a log with an extra variable' , { data : myImportantVariable }); // You can also pass multiple parameters containing arbitrary objects logger . info ( 'This is a log with 3 extra objects' , { data : myImportantVariable }, { correlationIds : { myCustomCorrelationId : 'foo-bar-baz' } }, { lambdaEvent : event } ); // Simply pass a string for logging additional data logger . info ( 'This is a log with additional string value' , 'string value' ); // Directly passing an object containing both the message and the additional info const logObject = { message : 'This is a log message' , additionalValue : 42 }; logger . info ( logObject ); return { foo : 'bar' }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { \"level\" : \"INFO\" , \"message\" : \"This is a log with an extra variable\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"data\" : { \"foo\" : \"bar\" } } { \"level\" : \"INFO\" , \"message\" : \"This is a log with 2 extra variables\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.466Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"data\" : { \"foo\" : \"bar\" }, \"correlationIds\" : { \"myCustomCorrelationId\" : \"foo-bar-baz\" }, \"lambdaEvent\" : { \"exampleEventData\" : { \"eventValue\" : 42 } } } { \"level\" : \"INFO\" , \"message\" : \"This is a log with additional string value\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"extra\" : \"string value\" } { \"level\" : \"INFO\" , \"message\" : \"This is a log message\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"additionalValue\" : 42 } Logging errors \u00b6 You can log errors by using the error method and pass the error object as parameter. The error will be logged with default key name error , but you can also pass your own custom key name. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( _event : any , _context : any ) : Promise < void > => { try { throw new Error ( 'Unexpected error #1' ); } catch ( error ) { // Log information about the error using the default \"error\" key logger . error ( 'This is the first error' , error as Error ); } try { throw new Error ( 'Unexpected error #2' ); } catch ( error ) { // Log information about the error using a custom \"myCustomErrorKey\" key logger . error ( 'This is the second error' , { myCustomErrorKey : error as Error } ); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log #1\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:12:39.345Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"error\" : { \"name\" : \"Error\" , \"location\" : \"/path/to/my/source-code/my-service/handler.ts:18\" , \"message\" : \"This is the first error\" , \"stack\" : \"Error: Unexpected error #1 at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:18:11) at Object.<anonymous> (/path/to/my/source-code/my-service/handler.ts:35:1) at Module._compile (node:internal/modules/cjs/loader:1108:14) at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23) at Module._extensions..js (node:internal/modules/cjs/loader:1137:10) at Object.require.extensions.<computed> [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12) at Module.load (node:internal/modules/cjs/loader:973:32) at Function.Module._load (node:internal/modules/cjs/loader:813:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\" } } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log #2\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:12:39.377Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"myCustomErrorKey\" : { \"name\" : \"Error\" , \"location\" : \"/path/to/my/source-code/my-service/handler.ts:24\" , \"message\" : \"This is the second error\" , \"stack\" : \"Error: Unexpected error #2 at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:24:11) at Object.<anonymous> (/path/to/my/source-code/my-service/handler.ts:35:1) at Module._compile (node:internal/modules/cjs/loader:1108:14) at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23) at Module._extensions..js (node:internal/modules/cjs/loader:1137:10) at Object.require.extensions.<computed> [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12) at Module.load (node:internal/modules/cjs/loader:973:32) at Function.Module._load (node:internal/modules/cjs/loader:813:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\" } } Logging errors and log level You can also log errors using the warn , info , and debug methods. Be aware of the log level though, you might miss those errors when analyzing the log later depending on the log level configuration. Advanced \u00b6 Using multiple Logger instances across your code \u00b6 Logger supports quick instance cloning via the createChild method. This can be useful for example if you want to enable multiple Loggers with different logging levels in the same Lambda invocation. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Logger } from '@aws-lambda-powertools/logger' ; // With this logger, all the INFO logs will be printed const logger = new Logger ({ logLevel : 'INFO' }); // With this logger, only the ERROR logs will be printed const childLogger = logger . createChild ({ logLevel : 'ERROR' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { logger . info ( 'This is an INFO log, from the parent logger' ); logger . error ( 'This is an ERROR log, from the parent logger' ); childLogger . info ( 'This is an INFO log, from the child logger' ); childLogger . error ( 'This is an ERROR log, from the child logger' ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log, from the parent logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.667Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log, from the parent logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.670Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log, from the child logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.670Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } Sampling logs \u00b6 Use sampling when you want to print all the log items generated in your code, based on a percentage of your concurrent/cold start invocations . You can do that by setting a \"sample rate\", a float value ranging from 0.0 (0%) to 1 (100%), by using a POWERTOOLS_LOGGER_SAMPLE_RATE env var or passing the sampleRateValue parameter in the Logger constructor. This number represents the probability that a Lambda invocation will print all the log items regardless of the log level setting. For example, by setting the \"sample rate\" to 0.5 , roughly 50% of your lambda invocations will print all the log items, including the debug ones. When is this useful? In production, to avoid log data pollution and reduce CloudWatch costs, developers are encouraged to use the logger with logLevel equal to ERROR or WARN . This means that only errors or warnings will be printed. However, it might still be useful to print all the logs (including debug ones) of a very small percentage of invocations to have a better understanding of the behaviour of your code in production even when there are no errors. Sampling decision happens at the Logger initialization. This means sampling may happen significantly more or less than depending on your traffic patterns, for example a steady low number of invocations and thus few cold starts. handler.ts Example CloudWatch Logs excerpt - Invocation #1 Example CloudWatch Logs excerpt - Invocation #2 Example CloudWatch Logs excerpt - Invocation #3 Example CloudWatch Logs excerpt - Invocation #4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Logger } from '@aws-lambda-powertools/logger' ; // Notice the log level set to 'ERROR' const logger = new Logger ({ logLevel : 'ERROR' , sampleRateValue : 0.5 }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { // This log item (equal to log level 'ERROR') will be printed to standard output // in all Lambda invocations logger . error ( 'This is an ERROR log' ); // These log items (below the log level 'ERROR') have ~50% chance // of being printed in a Lambda invocation logger . debug ( 'This is a DEBUG log that has 50% chance of being printed' ); logger . info ( 'This is an INFO log that has 50% chance of being printed' ); logger . warn ( 'This is a WARN log that has 50% chance of being printed' ); // Optional: refresh sample rate calculation on runtime // logger.refreshSampleRateCalculation(); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"DEBUG\" , \"message\" : \"This is a DEBUG log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.337Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"WARN\" , \"message\" : \"This is a WARN log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"DEBUG\" , \"message\" : \"This is a DEBUG log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.337Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"WARN\" , \"message\" : \"This is a WARN log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } Custom Log formatter (Bring Your Own Formatter) \u00b6 You can customize the structure (keys and values) of your log items by passing a custom log formatter, an object that implements the LogFormatter abstract class. handler.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Logger } from '@aws-lambda-powertools/logger' ; import { MyCompanyLogFormatter } from './utils/formatters/MyCompanyLogFormatter' ; const logger = new Logger ({ logFormatter : new MyCompanyLogFormatter (), logLevel : 'DEBUG' , serviceName : 'serverlessAirline' , sampleRateValue : 0.5 , persistentLogAttributes : { awsAccountId : process.env.AWS_ACCOUNT_ID , logger : { name : '@aws-lambda-powertools/logger' , version : '0.0.1' } }, }); export const handler = async ( event , context ) : Promise < void > => { logger . addContext ( context ); logger . info ( 'This is an INFO log' , { correlationIds : { myCustomCorrelationId : 'foo-bar-baz' } }); }; This is how the MyCompanyLogFormatter (dummy name) would look like: utils/formatters/MyCompanyLogFormatter.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { LogFormatter } from '@aws-lambda-powertools/logger' ; import { LogAttributes , UnformattedAttributes } from '@aws-lambda-powertools/logger/lib/types' ; // Replace this line with your own type type MyCompanyLog = LogAttributes ; class MyCompanyLogFormatter extends LogFormatter { public formatAttributes ( attributes : UnformattedAttributes ) : MyCompanyLog { return { message : attributes.message , service : attributes.serviceName , environment : attributes.environment , awsRegion : attributes.awsRegion , correlationIds : { awsRequestId : attributes.lambdaContext?.awsRequestId , xRayTraceId : attributes.xRayTraceId }, lambdaFunction : { name : attributes.lambdaContext?.functionName , arn : attributes.lambdaContext?.invokedFunctionArn , memoryLimitInMB : attributes.lambdaContext?.memoryLimitInMB , version : attributes.lambdaContext?.functionVersion , coldStart : attributes.lambdaContext?.coldStart , }, logLevel : attributes.logLevel , timestamp : this.formatTimestamp ( attributes . timestamp ), // You can extend this function logger : { sampleRateValue : attributes.sampleRateValue , }, }; } } export { MyCompanyLogFormatter }; This is how the printed log would look: Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"message\" : \"This is an INFO log\" , \"service\" : \"serverlessAirline\" , \"awsRegion\" : \"eu-west-1\" , \"correlationIds\" : { \"awsRequestId\" : \"c6af9ac6-7b61-11e6-9a41-93e812345678\" , \"xRayTraceId\" : \"abcdef123456abcdef123456abcdef123456\" , \"myCustomCorrelationId\" : \"foo-bar-baz\" }, \"lambdaFunction\" : { \"name\" : \"shopping-cart-api-lambda-prod-eu-west-1\" , \"arn\" : \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\" , \"memoryLimitInMB\" : 128 , \"version\" : \"$LATEST\" , \"coldStart\" : true }, \"logLevel\" : \"INFO\" , \"timestamp\" : \"2021-12-12T23:13:53.404Z\" , \"logger\" : { \"sampleRateValue\" : \"0.5\" , \"name\" : \"aws-lambda-powertools-typescript\" , \"version\" : \"0.0.1\" }, \"awsAccountId\" : \"123456789012\" } Testing your code \u00b6 Inject Lambda Context \u00b6 When unit testing your code that makes use of logger.addContext() or injectLambdaContext middleware and decorator, you can optionally pass a dummy Lambda Context if you want your logs to contain this information. This is a Jest sample that provides the minimum information necessary for Logger to inject context data: handler.test.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const dummyContext = { callbackWaitsForEmptyEventLoop : true , functionVersion : '$LATEST' , functionName : 'foo-bar-function' , memoryLimitInMB : '128' , logGroupName : '/aws/lambda/foo-bar-function' , logStreamName : '2021/03/09/[$LATEST]abcdef123456abcdef123456abcdef123456' , invokedFunctionArn : 'arn:aws:lambda:eu-west-1:123456789012:function:foo-bar-function' , awsRequestId : 'c6af9ac6-7b61-11e6-9a41-93e812345678' , getRemainingTimeInMillis : () => 1234 , done : () => console . log ( 'Done!' ), fail : () => console . log ( 'Failed!' ), succeed : () => console . log ( 'Succeeded!' ), }; describe ( 'MyUnitTest' , () => { test ( 'Lambda invoked successfully' , async () => { const testEvent = { test : 'test' }; await handler ( testEvent , dummyContext ); }); }); Tip If you don't want to declare your own dummy Lambda Context, you can use ContextExamples.helloworldContext from @aws-lambda-powertools/commons .","title":"Logger"},{"location":"core/logger/#key-features","text":"Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda context when instructed (disabled by default) Log sampling prints all logs for a percentage of invocations (disabled by default) Append additional keys to structured log at any point in time","title":"Key features"},{"location":"core/logger/#getting-started","text":"","title":"Getting started"},{"location":"core/logger/#installation","text":"Install the library in your project: 1 npm install @aws-lambda-powertools/logger","title":"Installation"},{"location":"core/logger/#usage","text":"The Logger utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Logger can keep track of a cold start and inject the appropriate fields into logs. handler.ts 1 2 3 4 5 6 7 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... };","title":"Usage"},{"location":"core/logger/#utility-settings","text":"The library requires two settings. You can set them as environment variables, or pass them in the constructor. These settings will be used across all logs emitted: Setting Description Environment variable Constructor parameter Logging level Sets how verbose Logger should be (INFO, by default). Supported values are: DEBUG , INFO , WARN , ERROR LOG_LEVEL logLevel Service name Sets the name of service of which the Lambda function is part of, that will be present across all log statements POWERTOOLS_SERVICE_NAME serviceName For a complete list of supported environment variables, refer to this section .","title":"Utility settings"},{"location":"core/logger/#example-using-aws-serverless-application-model-sam","text":"handler.ts template.yaml 1 2 3 4 5 6 7 8 9 10 import { Logger } from '@aws-lambda-powertools/logger' ; // Logger parameters fetched from the environment variables (see template.yaml tab) const logger = new Logger (); // You can also pass the parameters in the constructor // const logger = new Logger({ // logLevel: 'WARN', // serviceName: 'serverlessAirline' // }); 1 2 3 4 5 6 7 8 9 Resources : ShoppingCartApiFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Environment : Variables : LOG_LEVEL : WARN POWERTOOLS_SERVICE_NAME : serverlessAirline","title":"Example using AWS Serverless Application Model (SAM)"},{"location":"core/logger/#standard-structured-keys","text":"Your Logger will include the following keys to your structured logging (default log formatter): Key Example Note level : string INFO Logging level set for the Lambda function\"s invocation message : string Query performed to DynamoDB A descriptive, human-readable representation of this log item sampling_rate : float 0.1 When enabled, it prints all the logs of a percentage of invocations, e.g. 10% service : string serverlessAirline A unique name identifier of the service this Lambda function belongs to, by default service_undefined timestamp : string 2011-10-05T14:48:00.000Z Timestamp string in simplified extended ISO format (ISO 8601) xray_trace_id : string 1-5759e988-bd862e3fe1be46a994272793 X-Ray Trace ID. This value is always presented in Lambda environment, whether tracing is enabled or not. Logger will always log this value. error : Object { name: \"Error\", location: \"/my-project/handler.ts:18\", message: \"Unexpected error #1\", stack: \"[stacktrace]\"} Optional - An object containing information about the Error passed to the logger","title":"Standard structured keys"},{"location":"core/logger/#capturing-lambda-context-info","text":"You can enrich your structured logs with key Lambda context information in multiple ways. This functionality will include the following keys in your structured logs: Key Example cold_start : bool false function_name string shopping-cart-api-lambda-prod-eu-west-1 function_memory_size : number 128 function_arn : string arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1 function_request_id : string c6af9ac6-7b61-11e6-9a41-93e812345678 Manual Middy Middleware Decorator 1 2 3 4 5 6 7 8 9 10 11 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( _event , context ) : Promise < void > => { logger . addContext ( context ); logger . info ( 'This is an INFO log with some context' ); }; Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . 1 2 3 4 5 6 7 8 9 10 11 import { Logger , injectLambdaContext } from '@aws-lambda-powertools/logger' ; import middy from '@middy/core' ; const logger = new Logger (); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { logger . info ( 'This is an INFO log with some context' ); }; export const handler = middy ( lambdaHandler ) . use ( injectLambdaContext ( logger )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Logger } from '@aws-lambda-powertools/logger' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const logger = new Logger (); class Lambda implements LambdaInterface { // Decorate your handler class method @logger . injectLambdaContext () public async handler ( _event : any , _context : any ) : Promise < void > { logger . info ( 'This is an INFO log with some context' ); } } export const myFunction = new Lambda (); export const handler = myFunction . handler ; In each case, the printed log will look like this: Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 { \"cold_start\" : true , \"function_arn\" : \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\" , \"function_memory_size\" : 128 , \"function_request_id\" : \"c6af9ac6-7b61-11e6-9a41-93e812345678\" , \"function_name\" : \"shopping-cart-api-lambda-prod-eu-west-1\" , \"level\" : \"INFO\" , \"message\" : \"This is an INFO log with some context\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:21:08.921Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" }","title":"Capturing Lambda context info"},{"location":"core/logger/#appending-persistent-additional-log-keys-and-values","text":"You can append additional persistent keys and values in the logs generated during a Lambda invocation using either mechanism: Via the Logger's appendKeys method, for all log items generated after calling this method Passing them in the Logger's constructor To remove the keys you added, you can use the removeKeys method. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import { Logger } from '@aws-lambda-powertools/logger' ; // Add persistent log keys via the constructor const logger = new Logger ({ persistentLogAttributes : { aws_account_id : '123456789012' , aws_region : 'eu-west-1' , logger : { name : '@aws-lambda-powertools/logger' , version : '0.0.1' , }, extra_key : \"some-value\" } }); // OR add persistent log keys to an existing Logger instance with the appendKeys method: // logger.appendKeys({ // aws_account_id: '123456789012', // aws_region: 'eu-west-1', // logger: { // name: '@aws-lambda-powertools/logger', // version: '0.0.1', // }, // extra_key: \"some-value\" // }); export const handler = async ( _event : any , _context : any ) : Promise < unknown > => { // If you don't want to log the \"extra_key\" attribute in your logs, you can remove it logger . removeKeys ([ \"extra_key\" ]) // This info log will print all extra custom attributes added above // Extra attributes: logger object with name and version of the logger library, awsAccountId, awsRegion logger . info ( 'This is an INFO log' ); logger . info ( 'This is another INFO log' ); return { foo : 'bar' }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:49:58.084Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"aws_account_id\" : \"123456789012\" , \"aws_region\" : \"eu-west-1\" , \"logger\" : { \"name\" : \"@aws-lambda-powertools/logger\" , \"version\" : \"0.0.1\" } } { \"level\" : \"INFO\" , \"message\" : \"This is another INFO log\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T21:49:58.088Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"aws_account_id\" : \"123456789012\" , \"aws_region\" : \"eu-west-1\" , \"logger\" : { \"name\" : \"@aws-lambda-powertools/logger\" , \"version\" : \"0.0.1\" } } Logger will automatically ignore any key with an undefined value","title":"Appending persistent additional log keys and values"},{"location":"core/logger/#appending-additional-data-to-a-single-log-item","text":"You can append additional data to a single log item by passing objects as additional parameters. Pass a simple string for logging it with default key name extra Pass one or multiple objects containing arbitrary data to be logged. Each data object should be placed in an enclosing object as a single property value, you can name this property as you need: { myData: arbitraryObjectToLog } If you already have an object containing a message key and an additional property, you can pass this object directly handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( event : any , _context : any ) : Promise < unknown > => { const myImportantVariable = { foo : 'bar' }; // Log additional data in single log items // As second parameter logger . info ( 'This is a log with an extra variable' , { data : myImportantVariable }); // You can also pass multiple parameters containing arbitrary objects logger . info ( 'This is a log with 3 extra objects' , { data : myImportantVariable }, { correlationIds : { myCustomCorrelationId : 'foo-bar-baz' } }, { lambdaEvent : event } ); // Simply pass a string for logging additional data logger . info ( 'This is a log with additional string value' , 'string value' ); // Directly passing an object containing both the message and the additional info const logObject = { message : 'This is a log message' , additionalValue : 42 }; logger . info ( logObject ); return { foo : 'bar' }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { \"level\" : \"INFO\" , \"message\" : \"This is a log with an extra variable\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"data\" : { \"foo\" : \"bar\" } } { \"level\" : \"INFO\" , \"message\" : \"This is a log with 2 extra variables\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.466Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"data\" : { \"foo\" : \"bar\" }, \"correlationIds\" : { \"myCustomCorrelationId\" : \"foo-bar-baz\" }, \"lambdaEvent\" : { \"exampleEventData\" : { \"eventValue\" : 42 } } } { \"level\" : \"INFO\" , \"message\" : \"This is a log with additional string value\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"extra\" : \"string value\" } { \"level\" : \"INFO\" , \"message\" : \"This is a log message\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:06:17.463Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"additionalValue\" : 42 }","title":"Appending additional data to a single log item"},{"location":"core/logger/#logging-errors","text":"You can log errors by using the error method and pass the error object as parameter. The error will be logged with default key name error , but you can also pass your own custom key name. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Logger } from '@aws-lambda-powertools/logger' ; const logger = new Logger (); export const handler = async ( _event : any , _context : any ) : Promise < void > => { try { throw new Error ( 'Unexpected error #1' ); } catch ( error ) { // Log information about the error using the default \"error\" key logger . error ( 'This is the first error' , error as Error ); } try { throw new Error ( 'Unexpected error #2' ); } catch ( error ) { // Log information about the error using a custom \"myCustomErrorKey\" key logger . error ( 'This is the second error' , { myCustomErrorKey : error as Error } ); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log #1\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:12:39.345Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"error\" : { \"name\" : \"Error\" , \"location\" : \"/path/to/my/source-code/my-service/handler.ts:18\" , \"message\" : \"This is the first error\" , \"stack\" : \"Error: Unexpected error #1 at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:18:11) at Object.<anonymous> (/path/to/my/source-code/my-service/handler.ts:35:1) at Module._compile (node:internal/modules/cjs/loader:1108:14) at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23) at Module._extensions..js (node:internal/modules/cjs/loader:1137:10) at Object.require.extensions.<computed> [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12) at Module.load (node:internal/modules/cjs/loader:973:32) at Function.Module._load (node:internal/modules/cjs/loader:813:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\" } } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log #2\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:12:39.377Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" , \"myCustomErrorKey\" : { \"name\" : \"Error\" , \"location\" : \"/path/to/my/source-code/my-service/handler.ts:24\" , \"message\" : \"This is the second error\" , \"stack\" : \"Error: Unexpected error #2 at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:24:11) at Object.<anonymous> (/path/to/my/source-code/my-service/handler.ts:35:1) at Module._compile (node:internal/modules/cjs/loader:1108:14) at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23) at Module._extensions..js (node:internal/modules/cjs/loader:1137:10) at Object.require.extensions.<computed> [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12) at Module.load (node:internal/modules/cjs/loader:973:32) at Function.Module._load (node:internal/modules/cjs/loader:813:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\" } } Logging errors and log level You can also log errors using the warn , info , and debug methods. Be aware of the log level though, you might miss those errors when analyzing the log later depending on the log level configuration.","title":"Logging errors"},{"location":"core/logger/#advanced","text":"","title":"Advanced"},{"location":"core/logger/#using-multiple-logger-instances-across-your-code","text":"Logger supports quick instance cloning via the createChild method. This can be useful for example if you want to enable multiple Loggers with different logging levels in the same Lambda invocation. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Logger } from '@aws-lambda-powertools/logger' ; // With this logger, all the INFO logs will be printed const logger = new Logger ({ logLevel : 'INFO' }); // With this logger, only the ERROR logs will be printed const childLogger = logger . createChild ({ logLevel : 'ERROR' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { logger . info ( 'This is an INFO log, from the parent logger' ); logger . error ( 'This is an ERROR log, from the parent logger' ); childLogger . info ( 'This is an INFO log, from the child logger' ); childLogger . error ( 'This is an ERROR log, from the child logger' ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log, from the parent logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.667Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log, from the parent logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.670Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log, from the child logger\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:32:54.670Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" }","title":"Using multiple Logger instances across your code"},{"location":"core/logger/#sampling-logs","text":"Use sampling when you want to print all the log items generated in your code, based on a percentage of your concurrent/cold start invocations . You can do that by setting a \"sample rate\", a float value ranging from 0.0 (0%) to 1 (100%), by using a POWERTOOLS_LOGGER_SAMPLE_RATE env var or passing the sampleRateValue parameter in the Logger constructor. This number represents the probability that a Lambda invocation will print all the log items regardless of the log level setting. For example, by setting the \"sample rate\" to 0.5 , roughly 50% of your lambda invocations will print all the log items, including the debug ones. When is this useful? In production, to avoid log data pollution and reduce CloudWatch costs, developers are encouraged to use the logger with logLevel equal to ERROR or WARN . This means that only errors or warnings will be printed. However, it might still be useful to print all the logs (including debug ones) of a very small percentage of invocations to have a better understanding of the behaviour of your code in production even when there are no errors. Sampling decision happens at the Logger initialization. This means sampling may happen significantly more or less than depending on your traffic patterns, for example a steady low number of invocations and thus few cold starts. handler.ts Example CloudWatch Logs excerpt - Invocation #1 Example CloudWatch Logs excerpt - Invocation #2 Example CloudWatch Logs excerpt - Invocation #3 Example CloudWatch Logs excerpt - Invocation #4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Logger } from '@aws-lambda-powertools/logger' ; // Notice the log level set to 'ERROR' const logger = new Logger ({ logLevel : 'ERROR' , sampleRateValue : 0.5 }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { // This log item (equal to log level 'ERROR') will be printed to standard output // in all Lambda invocations logger . error ( 'This is an ERROR log' ); // These log items (below the log level 'ERROR') have ~50% chance // of being printed in a Lambda invocation logger . debug ( 'This is a DEBUG log that has 50% chance of being printed' ); logger . info ( 'This is an INFO log that has 50% chance of being printed' ); logger . warn ( 'This is a WARN log that has 50% chance of being printed' ); // Optional: refresh sample rate calculation on runtime // logger.refreshSampleRateCalculation(); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"DEBUG\" , \"message\" : \"This is a DEBUG log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.337Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"WARN\" , \"message\" : \"This is a WARN log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"DEBUG\" , \"message\" : \"This is a DEBUG log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.337Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"INFO\" , \"message\" : \"This is an INFO log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } { \"level\" : \"WARN\" , \"message\" : \"This is a WARN log that has 50% chance of being printed\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.338Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" } 1 2 3 4 5 6 7 8 { \"level\" : \"ERROR\" , \"message\" : \"This is an ERROR log\" , \"sampling_rate\" : \"0.5\" , \"service\" : \"serverlessAirline\" , \"timestamp\" : \"2021-12-12T22:59:06.334Z\" , \"xray_trace_id\" : \"abcdef123456abcdef123456abcdef123456\" }","title":"Sampling logs"},{"location":"core/logger/#custom-log-formatter-bring-your-own-formatter","text":"You can customize the structure (keys and values) of your log items by passing a custom log formatter, an object that implements the LogFormatter abstract class. handler.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { Logger } from '@aws-lambda-powertools/logger' ; import { MyCompanyLogFormatter } from './utils/formatters/MyCompanyLogFormatter' ; const logger = new Logger ({ logFormatter : new MyCompanyLogFormatter (), logLevel : 'DEBUG' , serviceName : 'serverlessAirline' , sampleRateValue : 0.5 , persistentLogAttributes : { awsAccountId : process.env.AWS_ACCOUNT_ID , logger : { name : '@aws-lambda-powertools/logger' , version : '0.0.1' } }, }); export const handler = async ( event , context ) : Promise < void > => { logger . addContext ( context ); logger . info ( 'This is an INFO log' , { correlationIds : { myCustomCorrelationId : 'foo-bar-baz' } }); }; This is how the MyCompanyLogFormatter (dummy name) would look like: utils/formatters/MyCompanyLogFormatter.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { LogFormatter } from '@aws-lambda-powertools/logger' ; import { LogAttributes , UnformattedAttributes } from '@aws-lambda-powertools/logger/lib/types' ; // Replace this line with your own type type MyCompanyLog = LogAttributes ; class MyCompanyLogFormatter extends LogFormatter { public formatAttributes ( attributes : UnformattedAttributes ) : MyCompanyLog { return { message : attributes.message , service : attributes.serviceName , environment : attributes.environment , awsRegion : attributes.awsRegion , correlationIds : { awsRequestId : attributes.lambdaContext?.awsRequestId , xRayTraceId : attributes.xRayTraceId }, lambdaFunction : { name : attributes.lambdaContext?.functionName , arn : attributes.lambdaContext?.invokedFunctionArn , memoryLimitInMB : attributes.lambdaContext?.memoryLimitInMB , version : attributes.lambdaContext?.functionVersion , coldStart : attributes.lambdaContext?.coldStart , }, logLevel : attributes.logLevel , timestamp : this.formatTimestamp ( attributes . timestamp ), // You can extend this function logger : { sampleRateValue : attributes.sampleRateValue , }, }; } } export { MyCompanyLogFormatter }; This is how the printed log would look: Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"message\" : \"This is an INFO log\" , \"service\" : \"serverlessAirline\" , \"awsRegion\" : \"eu-west-1\" , \"correlationIds\" : { \"awsRequestId\" : \"c6af9ac6-7b61-11e6-9a41-93e812345678\" , \"xRayTraceId\" : \"abcdef123456abcdef123456abcdef123456\" , \"myCustomCorrelationId\" : \"foo-bar-baz\" }, \"lambdaFunction\" : { \"name\" : \"shopping-cart-api-lambda-prod-eu-west-1\" , \"arn\" : \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\" , \"memoryLimitInMB\" : 128 , \"version\" : \"$LATEST\" , \"coldStart\" : true }, \"logLevel\" : \"INFO\" , \"timestamp\" : \"2021-12-12T23:13:53.404Z\" , \"logger\" : { \"sampleRateValue\" : \"0.5\" , \"name\" : \"aws-lambda-powertools-typescript\" , \"version\" : \"0.0.1\" }, \"awsAccountId\" : \"123456789012\" }","title":"Custom Log formatter (Bring Your Own Formatter)"},{"location":"core/logger/#testing-your-code","text":"","title":"Testing your code"},{"location":"core/logger/#inject-lambda-context","text":"When unit testing your code that makes use of logger.addContext() or injectLambdaContext middleware and decorator, you can optionally pass a dummy Lambda Context if you want your logs to contain this information. This is a Jest sample that provides the minimum information necessary for Logger to inject context data: handler.test.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const dummyContext = { callbackWaitsForEmptyEventLoop : true , functionVersion : '$LATEST' , functionName : 'foo-bar-function' , memoryLimitInMB : '128' , logGroupName : '/aws/lambda/foo-bar-function' , logStreamName : '2021/03/09/[$LATEST]abcdef123456abcdef123456abcdef123456' , invokedFunctionArn : 'arn:aws:lambda:eu-west-1:123456789012:function:foo-bar-function' , awsRequestId : 'c6af9ac6-7b61-11e6-9a41-93e812345678' , getRemainingTimeInMillis : () => 1234 , done : () => console . log ( 'Done!' ), fail : () => console . log ( 'Failed!' ), succeed : () => console . log ( 'Succeeded!' ), }; describe ( 'MyUnitTest' , () => { test ( 'Lambda invoked successfully' , async () => { const testEvent = { test : 'test' }; await handler ( testEvent , dummyContext ); }); }); Tip If you don't want to declare your own dummy Lambda Context, you can use ContextExamples.helloworldContext from @aws-lambda-powertools/commons .","title":"Inject Lambda Context"},{"location":"core/metrics/","text":"Do not use this library in production AWS Lambda Powertools for TypeScript is currently released as a beta developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release . Do not use this library for production workloads. Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF) . These metrics can be visualized through Amazon CloudWatch Console . Key features \u00b6 Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension Terminologies \u00b6 If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example ServerlessEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Metric terminology, visually explained Getting started \u00b6 Installation \u00b6 Install the library in your project: 1 npm install @aws-lambda-powertools/metrics Usage \u00b6 The Metrics utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Metrics can track cold start and emit the appropriate metrics. handler.ts 1 2 3 4 5 6 7 import { Metrics } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... }; Utility settings \u00b6 The library requires two settings. You can set them as environment variables, or pass them in the constructor. These settings will be used across all metrics emitted: Setting Description Environment variable Constructor parameter Metric namespace Logical container where all metrics will be placed e.g. serverlessAirline POWERTOOLS_METRICS_NAMESPACE namespace Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME serviceName For a complete list of supported environment variables, refer to this section . Tip Use your application name or main service as the metric namespace to easily group all metrics Example using AWS Serverless Application Model (SAM) \u00b6 The Metrics utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows Metrics to be aware of things like whether or not a given invocation had a cold start or not. handler.ts template.yml 1 2 3 4 5 6 7 8 9 10 import { Metrics } from '@aws-lambda-powertools/metrics' ; // Metrics parameters fetched from the environment variables (see template.yaml tab) const metrics = new Metrics (); // You can also pass the parameters in the constructor // const metrics = new Metrics({ // namespace: 'serverlessAirline', // serviceName: 'orders' // }); 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Environment : Variables : POWERTOOLS_SERVICE_NAME : orders POWERTOOLS_METRICS_NAMESPACE : serverlessAirline You can initialize Metrics anywhere in your code - It'll keep track of your aggregate metrics in memory. Creating metrics \u00b6 You can create metrics using the addMetric method, and you can create dimensions for all your aggregate metrics using the addDimension method. Metrics Metrics with custom dimensions 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . publishStoredMetrics (); }; 1 2 3 4 5 6 7 8 9 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addDimension ( 'environment' , 'prod' ); metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . publishStoredMetrics (); }; Autocomplete Metric Units Use the MetricUnit enum to easily find a supported metric unit by CloudWatch. Alternatively, you can pass the value as a string if you already know them e.g. \"Count\". Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics will automatically propagate all the metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behaviour. Adding multi-value metrics \u00b6 You can call addMetric() with the same name multiple times. The values will be grouped together in an array. addMetric() with the same name Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { Context } from 'aws-lambda' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( event : any , context : Context ) : Promise < void > => { metrics . addMetric ( 'performedActionA' , MetricUnits . Count , 2 ); // do something else... metrics . addMetric ( 'performedActionA' , MetricUnits . Count , 1 ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"performedActionA\" : [ 2 , 1 ], \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"performedActionA\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" } Adding default dimensions \u00b6 You can add default dimensions to your metrics by passing them as parameters in 4 ways: in the constructor in the Middy-compatible middleware using the setDefaultDimensions method in the decorator constructor Middy middleware setDefaultDimensions method with logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' , defaultDimensions : { 'environment' : 'prod' , 'foo' : 'bar' } }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; // Wrap the handler with middy export const handler = middy ( lambdaHandler ) // Use the middleware by passing the Metrics instance as a parameter . use ( logMetrics ( metrics , { defaultDimensions : { 'environment' : 'prod' , 'foo' : 'bar' } })); 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); metrics . setDefaultDimensions ({ 'environment' : 'prod' , 'foo' : 'bar' }); export const handler = async ( event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const DEFAULT_DIMENSIONS = { 'environment' : 'prod' , 'foo' : 'bar' }; export class MyFunction implements LambdaInterface { // Decorate your handler class method @metrics . logMetrics ({ defaultDimensions : DEFAULT_DIMENSIONS }) public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } If you'd like to remove them at some point, you can use the clearDefaultDimensions method. Flushing metrics \u00b6 As you finish adding all your metrics, you need to serialize and \"flush them\" by calling publishStoredMetrics() . This will print the metrics to standard output. You can flush metrics automatically using one of the following methods: manually Middy-compatible middleware class decorator Using the Middy middleware or decorator will automatically validate, serialize, and flush all your metrics. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be thrown. If you do not use the middleware or decorator, you have to flush your metrics manually. Metric validation If metrics are provided, and any of the following criteria are not met, a RangeError exception will be thrown: Maximum of 9 dimensions Namespace is set only once (or none) Metric units must be supported by CloudWatch Manually \u00b6 You can manually flush the metrics with publishStoredMetrics as follows: Warning Metrics, dimensions and namespace validation still applies. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 10 ); metrics . publishStoredMetrics (); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"successfulBooking\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" } Middy middleware \u00b6 See below an example of how to automatically flush metrics with the Middy-compatible logMetrics middleware. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] }, \"service\" : \"orders\" } Using the class decorator \u00b6 Info Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, check the middleware or manual method sections instead. See the official TypeScript documentation for more details. The logMetrics decorator of the metrics utility can be used when your Lambda handler function is implemented as method of a Class. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export class MyFunction implements LambdaInterface { @metrics . logMetrics () public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"successfulBooking\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] }, \"service\" : \"orders\" } Throwing a RangeError when no metrics are emitted \u00b6 If you want to ensure that at least one metric is emitted before you flush them, you can use the throwOnEmptyMetrics parameter and pass it to the middleware or decorator: handler.ts 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics , { throwOnEmptyMetrics : true })); Capturing a cold start invocation as metric \u00b6 You can optionally capture cold start metrics with the logMetrics middleware or decorator via the captureColdStartMetric param. Middy Middleware logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics , { captureColdStartMetric : true })); 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export class MyFunction implements LambdaInterface { @metrics . logMetrics ({ captureColdStartMetric : true }) public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add the function_name , service and default dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions. We do not emit 0 as a value for the ColdStart metric for cost-efficiency reasons. Let us know if you'd prefer a flag to override it. Advanced \u00b6 Adding metadata \u00b6 You can add high-cardinality data as part of your Metrics log with the addMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Warning This will not be available during metrics visualization - Use dimensions for this purpose handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . addMetadata ( 'bookingId' , '7051cd10-6283-11ec-90d6-0242ac120003' ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Namespace\" : \"exampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" , \"bookingId\" : \"7051cd10-6283-11ec-90d6-0242ac120003\" } Single metric with different dimensions \u00b6 CloudWatch EMF uses the same dimensions across all your metrics. Use singleMetric if you have a metric that should have different dimensions. Info For cost-efficiency, this feature would be used sparsely since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Middy Middleware logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addDimension ( 'metricUnit' , 'milliseconds' ); // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension: metrics . addMetric ( 'latency' , MetricUnits . Milliseconds , 56 ); const singleMetric = metrics . singleMetric (); // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension: singleMetric . addDimension ( 'metricType' , 'business' ); singleMetric . addMetric ( 'orderSubmitted' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); class Lambda implements LambdaInterface { @metrics . logMetrics () public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addDimension ( 'metricUnit' , 'milliseconds' ); // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension: metrics . addMetric ( 'latency' , MetricUnits . Milliseconds , 56 ); const singleMetric = metrics . singleMetric (); // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension: singleMetric . addDimension ( 'metricType' , 'business' ); singleMetric . addMetric ( 'orderSubmitted' , MetricUnits . Count , 1 ); } } export const myFunction = new Lambda (); export const handler = myFunction . handler ;","title":"Metrics"},{"location":"core/metrics/#key-features","text":"Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension","title":"Key features"},{"location":"core/metrics/#terminologies","text":"If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example ServerlessEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Metric terminology, visually explained","title":"Terminologies"},{"location":"core/metrics/#getting-started","text":"","title":"Getting started"},{"location":"core/metrics/#installation","text":"Install the library in your project: 1 npm install @aws-lambda-powertools/metrics","title":"Installation"},{"location":"core/metrics/#usage","text":"The Metrics utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Metrics can track cold start and emit the appropriate metrics. handler.ts 1 2 3 4 5 6 7 import { Metrics } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... };","title":"Usage"},{"location":"core/metrics/#utility-settings","text":"The library requires two settings. You can set them as environment variables, or pass them in the constructor. These settings will be used across all metrics emitted: Setting Description Environment variable Constructor parameter Metric namespace Logical container where all metrics will be placed e.g. serverlessAirline POWERTOOLS_METRICS_NAMESPACE namespace Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME serviceName For a complete list of supported environment variables, refer to this section . Tip Use your application name or main service as the metric namespace to easily group all metrics","title":"Utility settings"},{"location":"core/metrics/#example-using-aws-serverless-application-model-sam","text":"The Metrics utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows Metrics to be aware of things like whether or not a given invocation had a cold start or not. handler.ts template.yml 1 2 3 4 5 6 7 8 9 10 import { Metrics } from '@aws-lambda-powertools/metrics' ; // Metrics parameters fetched from the environment variables (see template.yaml tab) const metrics = new Metrics (); // You can also pass the parameters in the constructor // const metrics = new Metrics({ // namespace: 'serverlessAirline', // serviceName: 'orders' // }); 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Environment : Variables : POWERTOOLS_SERVICE_NAME : orders POWERTOOLS_METRICS_NAMESPACE : serverlessAirline You can initialize Metrics anywhere in your code - It'll keep track of your aggregate metrics in memory.","title":"Example using AWS Serverless Application Model (SAM)"},{"location":"core/metrics/#creating-metrics","text":"You can create metrics using the addMetric method, and you can create dimensions for all your aggregate metrics using the addDimension method. Metrics Metrics with custom dimensions 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . publishStoredMetrics (); }; 1 2 3 4 5 6 7 8 9 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addDimension ( 'environment' , 'prod' ); metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . publishStoredMetrics (); }; Autocomplete Metric Units Use the MetricUnit enum to easily find a supported metric unit by CloudWatch. Alternatively, you can pass the value as a string if you already know them e.g. \"Count\". Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics will automatically propagate all the metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behaviour.","title":"Creating metrics"},{"location":"core/metrics/#adding-multi-value-metrics","text":"You can call addMetric() with the same name multiple times. The values will be grouped together in an array. addMetric() with the same name Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { Context } from 'aws-lambda' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( event : any , context : Context ) : Promise < void > => { metrics . addMetric ( 'performedActionA' , MetricUnits . Count , 2 ); // do something else... metrics . addMetric ( 'performedActionA' , MetricUnits . Count , 1 ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"performedActionA\" : [ 2 , 1 ], \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"performedActionA\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" }","title":"Adding multi-value metrics"},{"location":"core/metrics/#adding-default-dimensions","text":"You can add default dimensions to your metrics by passing them as parameters in 4 ways: in the constructor in the Middy-compatible middleware using the setDefaultDimensions method in the decorator constructor Middy middleware setDefaultDimensions method with logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' , defaultDimensions : { 'environment' : 'prod' , 'foo' : 'bar' } }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; // Wrap the handler with middy export const handler = middy ( lambdaHandler ) // Use the middleware by passing the Metrics instance as a parameter . use ( logMetrics ( metrics , { defaultDimensions : { 'environment' : 'prod' , 'foo' : 'bar' } })); 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); metrics . setDefaultDimensions ({ 'environment' : 'prod' , 'foo' : 'bar' }); export const handler = async ( event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const DEFAULT_DIMENSIONS = { 'environment' : 'prod' , 'foo' : 'bar' }; export class MyFunction implements LambdaInterface { // Decorate your handler class method @metrics . logMetrics ({ defaultDimensions : DEFAULT_DIMENSIONS }) public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } If you'd like to remove them at some point, you can use the clearDefaultDimensions method.","title":"Adding default dimensions"},{"location":"core/metrics/#flushing-metrics","text":"As you finish adding all your metrics, you need to serialize and \"flush them\" by calling publishStoredMetrics() . This will print the metrics to standard output. You can flush metrics automatically using one of the following methods: manually Middy-compatible middleware class decorator Using the Middy middleware or decorator will automatically validate, serialize, and flush all your metrics. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be thrown. If you do not use the middleware or decorator, you have to flush your metrics manually. Metric validation If metrics are provided, and any of the following criteria are not met, a RangeError exception will be thrown: Maximum of 9 dimensions Namespace is set only once (or none) Metric units must be supported by CloudWatch","title":"Flushing metrics"},{"location":"core/metrics/#manually","text":"You can manually flush the metrics with publishStoredMetrics as follows: Warning Metrics, dimensions and namespace validation still applies. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 10 ); metrics . publishStoredMetrics (); }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"successfulBooking\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" }","title":"Manually"},{"location":"core/metrics/#middy-middleware","text":"See below an example of how to automatically flush metrics with the Middy-compatible logMetrics middleware. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] }, \"service\" : \"orders\" }","title":"Middy middleware"},{"location":"core/metrics/#using-the-class-decorator","text":"Info Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, check the middleware or manual method sections instead. See the official TypeScript documentation for more details. The logMetrics decorator of the metrics utility can be used when your Lambda handler function is implemented as method of a Class. handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export class MyFunction implements LambdaInterface { @metrics . logMetrics () public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"successfulBooking\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] }, \"service\" : \"orders\" }","title":"Using the class decorator"},{"location":"core/metrics/#throwing-a-rangeerror-when-no-metrics-are-emitted","text":"If you want to ensure that at least one metric is emitted before you flush them, you can use the throwOnEmptyMetrics parameter and pass it to the middleware or decorator: handler.ts 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics , { throwOnEmptyMetrics : true }));","title":"Throwing a RangeError when no metrics are emitted"},{"location":"core/metrics/#capturing-a-cold-start-invocation-as-metric","text":"You can optionally capture cold start metrics with the logMetrics middleware or decorator via the captureColdStartMetric param. Middy Middleware logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics , { captureColdStartMetric : true })); 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); export class MyFunction implements LambdaInterface { @metrics . logMetrics ({ captureColdStartMetric : true }) public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); } } If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add the function_name , service and default dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions. We do not emit 0 as a value for the ColdStart metric for cost-efficiency reasons. Let us know if you'd prefer a flag to override it.","title":"Capturing a cold start invocation as metric"},{"location":"core/metrics/#advanced","text":"","title":"Advanced"},{"location":"core/metrics/#adding-metadata","text":"You can add high-cardinality data as part of your Metrics log with the addMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Warning This will not be available during metrics visualization - Use dimensions for this purpose handler.ts Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addMetric ( 'successfulBooking' , MetricUnits . Count , 1 ); metrics . addMetadata ( 'bookingId' , '7051cd10-6283-11ec-90d6-0242ac120003' ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"successfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"serverlessAirline\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Namespace\" : \"exampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"successfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"orders\" , \"bookingId\" : \"7051cd10-6283-11ec-90d6-0242ac120003\" }","title":"Adding metadata"},{"location":"core/metrics/#single-metric-with-different-dimensions","text":"CloudWatch EMF uses the same dimensions across all your metrics. Use singleMetric if you have a metric that should have different dimensions. Info For cost-efficiency, this feature would be used sparsely since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Middy Middleware logMetrics decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Metrics , MetricUnits , logMetrics } from '@aws-lambda-powertools/metrics' ; import middy from '@middy/core' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { metrics . addDimension ( 'metricUnit' , 'milliseconds' ); // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension: metrics . addMetric ( 'latency' , MetricUnits . Milliseconds , 56 ); const singleMetric = metrics . singleMetric (); // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension: singleMetric . addDimension ( 'metricType' , 'business' ); singleMetric . addMetric ( 'orderSubmitted' , MetricUnits . Count , 1 ); }; export const handler = middy ( lambdaHandler ) . use ( logMetrics ( metrics )); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Metrics , MetricUnits } from '@aws-lambda-powertools/metrics' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const metrics = new Metrics ({ namespace : 'serverlessAirline' , serviceName : 'orders' }); class Lambda implements LambdaInterface { @metrics . logMetrics () public async handler ( _event : any , _context : any ) : Promise < void > { metrics . addDimension ( 'metricUnit' , 'milliseconds' ); // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension: metrics . addMetric ( 'latency' , MetricUnits . Milliseconds , 56 ); const singleMetric = metrics . singleMetric (); // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension: singleMetric . addDimension ( 'metricType' , 'business' ); singleMetric . addMetric ( 'orderSubmitted' , MetricUnits . Count , 1 ); } } export const myFunction = new Lambda (); export const handler = myFunction . handler ;","title":"Single metric with different dimensions"},{"location":"core/tracer/","text":"Do not use this library in production AWS Lambda Powertools for TypeScript is currently released as a beta developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release . Do not use this library for production workloads. Tracer is an opinionated thin wrapper for AWS X-Ray SDK for Node.js . Key features \u00b6 Auto capture cold start and service name as annotations, and responses or full exceptions as metadata Auto-disable when not running in AWS Lambda environment Automatically trace HTTP(s) clients and generate segments for each request Support tracing functions via decorators, middleware, and manual instrumentation Support tracing AWS SDK v2 and v3 via AWS X-Ray SDK for Node.js Getting started \u00b6 Installation \u00b6 Install the library in your project: 1 npm install @aws-lambda-powertools/tracer Usage \u00b6 The Tracer utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Tracer can track cold start and annotate the traces accordingly. handler.ts 1 2 3 4 5 6 7 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... }; Utility settings \u00b6 The library has three optional settings. You can set them as environment variables, or pass them in the constructor: Setting Description Environment variable Constructor parameter Tracing enabled Enables or disables tracing. By default tracing is enabled when running in AWS Lambda. POWERTOOLS_TRACE_ENABLED enabled Service name Sets an annotation with the name of the service across all traces e.g. serverlessAirline POWERTOOLS_SERVICE_NAME serviceName Capture HTTPs Requests Defines whether HTTPs requests will be traced or not, enabled by default when tracing is also enabled. POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS captureHTTPsRequests For a complete list of supported environment variables, refer to this section . Note Before your use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray. Example using AWS Serverless Application Model (SAM) \u00b6 The Tracer utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows Metrics to be aware of things like whether or not a given invocation had a cold start or not. handler.ts template.yml 1 2 3 4 5 6 7 8 9 import { Tracer } from '@aws-lambda-powertools/tracer' ; // Tracer parameter fetched from the environment variables (see template.yaml tab) const tracer = new Tracer (); // You can also pass the parameter in the constructor // const tracer = new Tracer({ // serviceName: \"serverlessAirline\" // }); 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : serverlessAirline Lambda handler \u00b6 You can quickly start by importing the Tracer class, initialize it outside the Lambda handler, and instrument your function. Manual Middy Middleware Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , context : any ) : Promise < unknown > => { const segment = tracer . getSegment (); // This is the facade segment (the one that is created by AWS Lambda) // Create subsegment for the function & set it as active const subsegment = segment . addNewSubsegment ( `## ${ process . env . _HANDLER } ` ); tracer . setSegment ( subsegment ); // Annotate the subsegment with the cold start & serviceName tracer . annotateColdStart (); tracer . addServiceNameAnnotation (); let res ; try { /* ... */ // Add the response as metadata tracer . addResponseAsMetadata ( res , process . env . _HANDLER ); } catch ( err ) { // Add the error as metadata tracer . addErrorAsMetadata ( err as Error ); throw err ; } finally { // Close subsegment (the AWS Lambda one is closed automatically) subsegment . close (); // Set back the facade segment as active again tracer . setSegment ( segment ); } return res ; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Tracer , captureLambdaHandler } from '@aws-lambda-powertools/tracer' ; import middy from '@middy/core' ; // (1) const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { /* ... */ }; // Wrap the handler with middy export const handler = middy ( lambdaHandler ) // Use the middleware by passing the Tracer instance as a parameter . use ( captureLambdaHandler ( tracer )); Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . Info Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, use the middleware or the manual instrumentations instead. See the official TypeScript documentation for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Tracer } from '@aws-lambda-powertools/tracer' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); class Lambda implements LambdaInterface { // Decorate your handler class method @tracer . captureLambdaHandler () public async handler ( _event : any , _context : any ) : Promise < void > { /* ... */ } } export const handlerClass = new Lambda (); export const handler = handlerClass . handler ; When using the captureLambdaHandler decorator or middleware, Tracer performs these additional tasks to ease operations: Handles the lifecycle of the subsegment Creates a ColdStart annotation to easily filter traces that have had an initialization overhead Creates a Service annotation to easily filter traces that have a specific service name Captures any response, or full exceptions generated by the handler, and include them as tracing metadata Annotations & Metadata \u00b6 Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations Metadata You can add annotations using putAnnotation method. 1 2 3 4 5 6 7 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { tracer . putAnnotation ( 'successfulBooking' , true ); }; You can add metadata using putMetadata method. 1 2 3 4 5 6 7 8 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { const res ; /* ... */ tracer . putMetadata ( 'paymentResponse' , res ); }; Methods \u00b6 You can trace other Class methods using the captureMethod decorator or any arbitrary function using manual instrumentation. Manual Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const getChargeId = async () : Promise < unknown > => { const parentSubsegment = tracer . getSegment (); // This is the subsegment currently active // Create subsegment for the function & set it as active const subsegment = parentSubsegment . addNewSubsegment ( `### chargeId` ); tracer . setSegment ( subsegment ); let res ; try { /* ... */ // Add the response as metadata tracer . addResponseAsMetadata ( res , 'chargeId' ); } catch ( err ) { // Add the error as metadata tracer . addErrorAsMetadata ( err as Error ); throw err ; } // Close subsegment (the AWS Lambda one is closed automatically) subsegment . close (); // Set the facade segment as active again tracer . setSegment ( parentSubsegment ); return res ; }; export const handler = async ( _event : any , _context : any ) : Promise < void > => { const chargeId = getChargeId (); const payment = collectPayment ( chargeId ); /* ... */ }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Tracer } from '@aws-lambda-powertools/tracer' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); class Lambda implements LambdaInterface { // Decorate your class method @tracer . captureMethod () public getChargeId () : string { /* ... */ return 'foo bar' ; } public async handler ( _event : any , _context : any ) : Promise < void > { /* ... */ } } export const myFunction = new Lambda (); export const handler = myFunction . handler ; Patching AWS SDK clients \u00b6 Tracer can patch any AWS SDK clients and create traces when your application makes calls to AWS services. Info The following snippet assumes you are using the AWS SDK v3 for JavaScript You can patch any AWS SDK clients by calling the captureAWSv3Client method: index.ts 1 2 3 4 5 import { S3Client } from '@aws-sdk/client-s3' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const client = tracer . captureAWSv3Client ( new S3Client ({})); Info The following two snippets assume you are using the AWS SDK v2 for JavaScript You can patch all AWS SDK v2 clients by calling the captureAWS method: index.ts 1 2 3 4 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const AWS = tracer . captureAWS ( require ( 'aws-sdk' )); If you're looking to shave a few microseconds, or milliseconds depending on your function memory configuration, you can patch only specific AWS SDK v2 clients using captureAWSClient : index.ts 1 2 3 4 5 import { S3 } from 'aws-sdk' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const s3 = tracer . captureAWSClient ( new S3 ()); Tracing HTTP requests \u00b6 When your function makes calls to HTTP APIs, Tracer automatically traces those calls and add the API to the service graph as a downstream service. You can opt-out from this feature by setting the POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS=false environment variable or by passing the captureHTTPSRequests: false option to the Tracer constructor. Info The following snippet shows how to trace axios requests, but you can use any HTTP client library built on top of http or https . Support to 3rd party HTTP clients is provided on a best effort basis. index.ts Example Raw X-Ray Trace excerpt 1 2 3 4 5 6 7 8 import { Tracer } from '@aws-lambda-powertools/tracer' ; import axios from 'axios' ; // (1) const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( event : unknown , context : Context ) : Promise < void > => { await axios . get ( 'https://httpbin.org/status/200' ); }; You can install the axios package using npm i axios 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"id\" : \"22883fbc730e3a0b\" , \"name\" : \"## index.handler\" , \"start_time\" : 1647956168.22749 , \"end_time\" : 1647956169.0679862 , \"subsegments\" : [ { \"id\" : \"ab82ab2b7d525d8f\" , \"name\" : \"httpbin.org\" , \"start_time\" : 1647956168.407 , \"end_time\" : 1647956168.945 , \"http\" : { \"request\" : { \"url\" : \"https://httpbin.org/status/200\" , \"method\" : \"GET\" }, \"response\" : { \"status\" : 200 , \"content_length\" : 0 } }, \"namespace\" : \"remote\" } ] } Advanced \u00b6 Disabling response auto-capture \u00b6 Use POWERTOOLS_TRACER_CAPTURE_RESPONSE=false environment variable to instruct Tracer not to serialize function responses as metadata. This is commonly useful in three scenarios You might return sensitive information you don't want it to be added to your traces You might manipulate streaming objects that can be read only once ; this prevents subsequent calls from being empty You might return more than 64K of data e.g., message too long error Disabling exception auto-capture \u00b6 Use POWERTOOLS_TRACER_CAPTURE_ERROR=false environment variable to instruct Tracer not to serialize exceptions as metadata. Commonly useful in one scenario You might return sensitive information from exceptions, stack traces you might not control Escape hatch mechanism \u00b6 You can use tracer.provider attribute to access all methods provided by the AWS X-Ray SDK . This is useful when you need a feature available in X-Ray that is not available in the Tracer utility, for example SQL queries tracing , or a custom logger . index.ts 1 2 3 4 5 6 7 import { Logger } from '@aws-lambda-powertools/logger' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const serviceName = 'serverlessAirline' ; const logger = new Logger ({ serviceName : serviceName }); const tracer = new Tracer ({ serviceName : serviceName }); tracer . provider . setLogger ( logger ); Testing your code \u00b6 Tracer is disabled by default when not running in the AWS Lambda environment - This means no code changes or environment variables to be set. Tips \u00b6 Use annotations on key operations to slice and dice traces, create unique views, and create metrics from it via Trace Groups Use a namespace when adding metadata to group data more easily Annotations and metadata are added to the currently open subsegment. If you want them in a specific subsegment, create one via the escape hatch mechanism","title":"Tracer"},{"location":"core/tracer/#key-features","text":"Auto capture cold start and service name as annotations, and responses or full exceptions as metadata Auto-disable when not running in AWS Lambda environment Automatically trace HTTP(s) clients and generate segments for each request Support tracing functions via decorators, middleware, and manual instrumentation Support tracing AWS SDK v2 and v3 via AWS X-Ray SDK for Node.js","title":"Key features"},{"location":"core/tracer/#getting-started","text":"","title":"Getting started"},{"location":"core/tracer/#installation","text":"Install the library in your project: 1 npm install @aws-lambda-powertools/tracer","title":"Installation"},{"location":"core/tracer/#usage","text":"The Tracer utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, Tracer can track cold start and annotate the traces accordingly. handler.ts 1 2 3 4 5 6 7 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event , _context ) : Promise < void > => { // ... };","title":"Usage"},{"location":"core/tracer/#utility-settings","text":"The library has three optional settings. You can set them as environment variables, or pass them in the constructor: Setting Description Environment variable Constructor parameter Tracing enabled Enables or disables tracing. By default tracing is enabled when running in AWS Lambda. POWERTOOLS_TRACE_ENABLED enabled Service name Sets an annotation with the name of the service across all traces e.g. serverlessAirline POWERTOOLS_SERVICE_NAME serviceName Capture HTTPs Requests Defines whether HTTPs requests will be traced or not, enabled by default when tracing is also enabled. POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS captureHTTPsRequests For a complete list of supported environment variables, refer to this section . Note Before your use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray.","title":"Utility settings"},{"location":"core/tracer/#example-using-aws-serverless-application-model-sam","text":"The Tracer utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows Metrics to be aware of things like whether or not a given invocation had a cold start or not. handler.ts template.yml 1 2 3 4 5 6 7 8 9 import { Tracer } from '@aws-lambda-powertools/tracer' ; // Tracer parameter fetched from the environment variables (see template.yaml tab) const tracer = new Tracer (); // You can also pass the parameter in the constructor // const tracer = new Tracer({ // serviceName: \"serverlessAirline\" // }); 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : Runtime : nodejs16.x Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : serverlessAirline","title":"Example using AWS Serverless Application Model (SAM)"},{"location":"core/tracer/#lambda-handler","text":"You can quickly start by importing the Tracer class, initialize it outside the Lambda handler, and instrument your function. Manual Middy Middleware Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , context : any ) : Promise < unknown > => { const segment = tracer . getSegment (); // This is the facade segment (the one that is created by AWS Lambda) // Create subsegment for the function & set it as active const subsegment = segment . addNewSubsegment ( `## ${ process . env . _HANDLER } ` ); tracer . setSegment ( subsegment ); // Annotate the subsegment with the cold start & serviceName tracer . annotateColdStart (); tracer . addServiceNameAnnotation (); let res ; try { /* ... */ // Add the response as metadata tracer . addResponseAsMetadata ( res , process . env . _HANDLER ); } catch ( err ) { // Add the error as metadata tracer . addErrorAsMetadata ( err as Error ); throw err ; } finally { // Close subsegment (the AWS Lambda one is closed automatically) subsegment . close (); // Set back the facade segment as active again tracer . setSegment ( segment ); } return res ; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 import { Tracer , captureLambdaHandler } from '@aws-lambda-powertools/tracer' ; import middy from '@middy/core' ; // (1) const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const lambdaHandler = async ( _event : any , _context : any ) : Promise < void > => { /* ... */ }; // Wrap the handler with middy export const handler = middy ( lambdaHandler ) // Use the middleware by passing the Tracer instance as a parameter . use ( captureLambdaHandler ( tracer )); Using Middy for the first time? You can install Middy by running npm i @middy/core . Learn more about its usage and lifecycle in the official Middy documentation . Info Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, use the middleware or the manual instrumentations instead. See the official TypeScript documentation for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Tracer } from '@aws-lambda-powertools/tracer' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); class Lambda implements LambdaInterface { // Decorate your handler class method @tracer . captureLambdaHandler () public async handler ( _event : any , _context : any ) : Promise < void > { /* ... */ } } export const handlerClass = new Lambda (); export const handler = handlerClass . handler ; When using the captureLambdaHandler decorator or middleware, Tracer performs these additional tasks to ease operations: Handles the lifecycle of the subsegment Creates a ColdStart annotation to easily filter traces that have had an initialization overhead Creates a Service annotation to easily filter traces that have a specific service name Captures any response, or full exceptions generated by the handler, and include them as tracing metadata","title":"Lambda handler"},{"location":"core/tracer/#annotations-metadata","text":"Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations Metadata You can add annotations using putAnnotation method. 1 2 3 4 5 6 7 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { tracer . putAnnotation ( 'successfulBooking' , true ); }; You can add metadata using putMetadata method. 1 2 3 4 5 6 7 8 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( _event : any , _context : any ) : Promise < void > => { const res ; /* ... */ tracer . putMetadata ( 'paymentResponse' , res ); };","title":"Annotations &amp; Metadata"},{"location":"core/tracer/#methods","text":"You can trace other Class methods using the captureMethod decorator or any arbitrary function using manual instrumentation. Manual Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const getChargeId = async () : Promise < unknown > => { const parentSubsegment = tracer . getSegment (); // This is the subsegment currently active // Create subsegment for the function & set it as active const subsegment = parentSubsegment . addNewSubsegment ( `### chargeId` ); tracer . setSegment ( subsegment ); let res ; try { /* ... */ // Add the response as metadata tracer . addResponseAsMetadata ( res , 'chargeId' ); } catch ( err ) { // Add the error as metadata tracer . addErrorAsMetadata ( err as Error ); throw err ; } // Close subsegment (the AWS Lambda one is closed automatically) subsegment . close (); // Set the facade segment as active again tracer . setSegment ( parentSubsegment ); return res ; }; export const handler = async ( _event : any , _context : any ) : Promise < void > => { const chargeId = getChargeId (); const payment = collectPayment ( chargeId ); /* ... */ }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Tracer } from '@aws-lambda-powertools/tracer' ; import { LambdaInterface } from '@aws-lambda-powertools/commons' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); class Lambda implements LambdaInterface { // Decorate your class method @tracer . captureMethod () public getChargeId () : string { /* ... */ return 'foo bar' ; } public async handler ( _event : any , _context : any ) : Promise < void > { /* ... */ } } export const myFunction = new Lambda (); export const handler = myFunction . handler ;","title":"Methods"},{"location":"core/tracer/#patching-aws-sdk-clients","text":"Tracer can patch any AWS SDK clients and create traces when your application makes calls to AWS services. Info The following snippet assumes you are using the AWS SDK v3 for JavaScript You can patch any AWS SDK clients by calling the captureAWSv3Client method: index.ts 1 2 3 4 5 import { S3Client } from '@aws-sdk/client-s3' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const client = tracer . captureAWSv3Client ( new S3Client ({})); Info The following two snippets assume you are using the AWS SDK v2 for JavaScript You can patch all AWS SDK v2 clients by calling the captureAWS method: index.ts 1 2 3 4 import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const AWS = tracer . captureAWS ( require ( 'aws-sdk' )); If you're looking to shave a few microseconds, or milliseconds depending on your function memory configuration, you can patch only specific AWS SDK v2 clients using captureAWSClient : index.ts 1 2 3 4 5 import { S3 } from 'aws-sdk' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); const s3 = tracer . captureAWSClient ( new S3 ());","title":"Patching AWS SDK clients"},{"location":"core/tracer/#tracing-http-requests","text":"When your function makes calls to HTTP APIs, Tracer automatically traces those calls and add the API to the service graph as a downstream service. You can opt-out from this feature by setting the POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS=false environment variable or by passing the captureHTTPSRequests: false option to the Tracer constructor. Info The following snippet shows how to trace axios requests, but you can use any HTTP client library built on top of http or https . Support to 3rd party HTTP clients is provided on a best effort basis. index.ts Example Raw X-Ray Trace excerpt 1 2 3 4 5 6 7 8 import { Tracer } from '@aws-lambda-powertools/tracer' ; import axios from 'axios' ; // (1) const tracer = new Tracer ({ serviceName : 'serverlessAirline' }); export const handler = async ( event : unknown , context : Context ) : Promise < void > => { await axios . get ( 'https://httpbin.org/status/200' ); }; You can install the axios package using npm i axios 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \"id\" : \"22883fbc730e3a0b\" , \"name\" : \"## index.handler\" , \"start_time\" : 1647956168.22749 , \"end_time\" : 1647956169.0679862 , \"subsegments\" : [ { \"id\" : \"ab82ab2b7d525d8f\" , \"name\" : \"httpbin.org\" , \"start_time\" : 1647956168.407 , \"end_time\" : 1647956168.945 , \"http\" : { \"request\" : { \"url\" : \"https://httpbin.org/status/200\" , \"method\" : \"GET\" }, \"response\" : { \"status\" : 200 , \"content_length\" : 0 } }, \"namespace\" : \"remote\" } ] }","title":"Tracing HTTP requests"},{"location":"core/tracer/#advanced","text":"","title":"Advanced"},{"location":"core/tracer/#disabling-response-auto-capture","text":"Use POWERTOOLS_TRACER_CAPTURE_RESPONSE=false environment variable to instruct Tracer not to serialize function responses as metadata. This is commonly useful in three scenarios You might return sensitive information you don't want it to be added to your traces You might manipulate streaming objects that can be read only once ; this prevents subsequent calls from being empty You might return more than 64K of data e.g., message too long error","title":"Disabling response auto-capture"},{"location":"core/tracer/#disabling-exception-auto-capture","text":"Use POWERTOOLS_TRACER_CAPTURE_ERROR=false environment variable to instruct Tracer not to serialize exceptions as metadata. Commonly useful in one scenario You might return sensitive information from exceptions, stack traces you might not control","title":"Disabling exception auto-capture"},{"location":"core/tracer/#escape-hatch-mechanism","text":"You can use tracer.provider attribute to access all methods provided by the AWS X-Ray SDK . This is useful when you need a feature available in X-Ray that is not available in the Tracer utility, for example SQL queries tracing , or a custom logger . index.ts 1 2 3 4 5 6 7 import { Logger } from '@aws-lambda-powertools/logger' ; import { Tracer } from '@aws-lambda-powertools/tracer' ; const serviceName = 'serverlessAirline' ; const logger = new Logger ({ serviceName : serviceName }); const tracer = new Tracer ({ serviceName : serviceName }); tracer . provider . setLogger ( logger );","title":"Escape hatch mechanism"},{"location":"core/tracer/#testing-your-code","text":"Tracer is disabled by default when not running in the AWS Lambda environment - This means no code changes or environment variables to be set.","title":"Testing your code"},{"location":"core/tracer/#tips","text":"Use annotations on key operations to slice and dice traces, create unique views, and create metrics from it via Trace Groups Use a namespace when adding metadata to group data more easily Annotations and metadata are added to the currently open subsegment. If you want them in a specific subsegment, create one via the escape hatch mechanism","title":"Tips"}]}