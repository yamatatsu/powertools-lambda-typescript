{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>Powertools is a developer toolkit to implement Serverless best practices and increase developer velocity.</p> <p>You can use Powertools in both TypeScript and JavaScript code bases.</p>  Tip <p>Powertools is also available for Python, Java, and .NET</p>   Support this project by becoming a reference customer, sharing your work, or using Layers  <p>You can choose to support us in three ways:</p> <p>1) Become a reference customers. This gives us permission to list your company in our documentation.</p> <p>2) Share your work. Blog posts, video, sample projects you used Powertools!</p> <p>3) Use Lambda Layers, if possible. This helps us understand who uses Powertools in a non-intrusive way, and helps us gain future investments for other Lambda Powertools languages.</p> <p>When using Layers, you can add Lambda Powertools as a <code>devDependency</code> to not impact the development process.</p>"},{"location":"#install","title":"Install","text":"<p>You can install Powertools using one of the following options:</p> <ul> <li>Lambda Layer: arn:aws:lambda:{region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9</li> <li>npm: <code>npm install @aws-lambda-powertools/tracer @aws-lambda-powertools/metrics @aws-lambda-powertools/logger</code></li> </ul>"},{"location":"#lambda-layer","title":"Lambda Layer","text":"As of now, Container Image deployment (OCI) or inline Lambda functions do not support Lambda Layers.  <p>Lambda Layer is a .zip file archive that can contain additional code, pre-packaged dependencies, data,  or configuration files. Layers promote code sharing and separation of responsibilities so that you can iterate faster on writing business logic.</p> <p>You can include Lambda Powertools Lambda Layer using AWS Lambda Console, or your preferred deployment framework.</p>  Note: Click to expand and copy any regional Lambda Layer ARN    Region Layer ARN     <code>us-east-1</code> arn:aws:lambda:us-east-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>us-east-2</code> arn:aws:lambda:us-east-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>us-west-1</code> arn:aws:lambda:us-west-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>us-west-2</code> arn:aws:lambda:us-west-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-south-1</code> arn:aws:lambda:ap-south-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-east-1</code> arn:aws:lambda:ap-east-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-northeast-1</code> arn:aws:lambda:ap-northeast-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-northeast-2</code> arn:aws:lambda:ap-northeast-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-northeast-3</code> arn:aws:lambda:ap-northeast-3:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-southeast-1</code> arn:aws:lambda:ap-southeast-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-southeast-2</code> arn:aws:lambda:ap-southeast-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-southeast-3</code> arn:aws:lambda:ap-southeast-3:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ap-southeast-4</code> arn:aws:lambda:ap-southeast-4:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-central-1</code> arn:aws:lambda:eu-central-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-central-2</code> arn:aws:lambda:eu-central-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-west-1</code> arn:aws:lambda:eu-west-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-west-2</code> arn:aws:lambda:eu-west-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-west-3</code> arn:aws:lambda:eu-west-3:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-north-1</code> arn:aws:lambda:eu-north-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-south-1</code> arn:aws:lambda:eu-south-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>eu-south-2</code> arn:aws:lambda:eu-south-2:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>ca-central-1</code> arn:aws:lambda:ca-central-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>sa-east-1</code> arn:aws:lambda:sa-east-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>af-south-1</code> arn:aws:lambda:af-south-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9   <code>me-south-1</code> arn:aws:lambda:me-south-1:094274105915:layer:AWSLambdaPowertoolsTypeScript:9      Note: Click to expand and copy code snippets for popular frameworks SAMServerless frameworkCDKTerraformPulumiAmplify   <pre><code>MyLambdaFunction:\n  Type: AWS::Serverless::Function\n    Properties:\n      Layers:\n        - !Sub arn:aws:lambda:${AWS::Region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9\n</code></pre> <p>If you use <code>esbuild</code> to bundle your code, make sure to exclude <code>@aws-lambda-powertools</code> from being bundled since the packages will be already present the Layer:</p> <pre><code>MyLambdaFunction:\n  Type: AWS::Serverless::Function\n  Properties:\n    ...\n    Metadata: \n      # Manage esbuild properties\n      BuildMethod: esbuild\n      BuildProperties:\n      Minify: true\n      External:\n        - '@aws-lambda-powertools/commons'\n        - '@aws-lambda-powertools/logger'\n        - '@aws-lambda-powertools/metrics'\n        - '@aws-lambda-powertools/tracer'\n</code></pre> <p>Check the documentation for more details.</p>   <pre><code>functions:\n  hello:\n    handler: lambda_function.lambda_handler\n    layers:\n      - arn:aws:lambda:${aws::region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9\n</code></pre> <p>If you use <code>esbuild</code> to bundle your code, make sure to exclude <code>@aws-lambda-powertools</code> from being bundled since the packages will be already present the Layer:</p> <pre><code>custom:\n  esbuild:\n    external:\n      - '@aws-lambda-powertools/commons'\n      - '@aws-lambda-powertools/logger'\n      - '@aws-lambda-powertools/metrics'\n      - '@aws-lambda-powertools/tracer'\n</code></pre> <p>Check the documentation for more details.</p>   <pre><code>import * as cdk from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nexport class SampleFunctionWithLayer extends Construct {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    // Create a Layer with AWS Lambda Powertools for TypeScript\n    const powertoolsLayer = lambda.LayerVersion.fromLayerVersionArn(\n      this,\n      'PowertoolsLayer',\n      `arn:aws:lambda:${cdk.Stack.of(this).region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9`\n    );\n\n    new lambda.Function(this, 'Function', {\n      runtime: lambda.Runtime.NODEJS_16_X,\n      // Add the Layer to a Lambda function\n      layers: [powertoolsLayer],\n      code: lambda.Code.fromInline(`...`),\n      handler: 'index.handler',\n    });\n  }\n}\n</code></pre> <p>If you use <code>esbuild</code> to bundle your code, make sure to exclude <code>@aws-lambda-powertools</code> from being bundled since the packages will be already present the Layer:</p> <pre><code>new awsLambdaNodejs.NodejsFunction(this, 'Function', {\n  ...\n  bundling: {\n    externalModules: [\n      '@aws-lambda-powertools/commons',\n      '@aws-lambda-powertools/logger',\n      '@aws-lambda-powertools/metrics',\n      '@aws-lambda-powertools/tracer',\n    ],\n  }\n});\n</code></pre> <p>Check the documentation for more details.</p>   <pre><code>terraform {\n  required_version = \"~&gt; 1.0.5\"\n  required_providers {\n    aws = \"~&gt; 3.50.0\"\n  }\n}\n\nprovider \"aws\" {\n  region  = \"{aws::region}\"\n}\n\nresource \"aws_lambda_function\" \"test_lambda\" {\n  filename      = \"lambda_function_payload.zip\"\n  function_name = \"lambda_function_name\"\n  role          = ...\n  handler       = \"index.handler\"\n  runtime       = \"nodejs16.x\"\n  layers        = [\"arn:aws:lambda:{aws::region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9\"]\n  source_code_hash = filebase64sha256(\"lambda_function_payload.zip\")\n}\n</code></pre>   <pre><code>import * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst role = new aws.iam.Role(\"role\", {\n    assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal(aws.iam.Principals.LambdaPrincipal),\n    managedPolicyArns: [aws.iam.ManagedPolicies.AWSLambdaBasicExecutionRole]\n});\n\nconst lambdaFunction = new aws.lambda.Function(\"function\", {\n    layers: [\n        pulumi.interpolate`arn:aws:lambda:${aws.getRegionOutput().name}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9`\n    ],\n    code: new pulumi.asset.FileArchive(\"lambda_function_payload.zip\"),\n    tracingConfig: {\n        mode: \"Active\"\n    },\n    runtime: aws.lambda.Runtime.NodeJS16dX,\n    handler: \"index.handler\",\n    role: role.arn,\n    architectures: [\"x86_64\"]\n});\n</code></pre>   <pre><code># Create a new one with the layer\n\u276f amplify add function\n? Select which capability you want to add: Lambda function (serverless function)\n? Provide an AWS Lambda function name: &lt;NAME-OF-FUNCTION&gt;\n? Choose the runtime that you want to use: NodeJS\n? Do you want to configure advanced settings? Yes\n...\n? Do you want to enable Lambda layers for this function? Yes\n? Enter up to 5 existing Lambda layer ARNs (comma-separated): arn:aws:lambda:{aws::region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9\n\u276f amplify push -y\n\n# Updating an existing function and add the layer\n\u276f amplify update function\n? Select the Lambda function you want to update test2\nGeneral information\n- Name: &lt;NAME-OF-FUNCTION&gt;\n? Which setting do you want to update? Lambda layers configuration\n? Do you want to enable Lambda layers for this function? Yes\n? Enter up to 5 existing Lambda layer ARNs (comma-separated): arn:aws:lambda:{aws::region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9\n? Do you want to edit the local lambda function now? No\n</code></pre>      <p>Using Powertools via Lambda Layer? Simply add the Powertools utilities you are using as a development dependency.</p>   Want to inspect the contents of the Layer? <p>Change {region} to your AWS region, e.g. <code>eu-west-1</code></p> AWS CLI<pre><code>aws lambda get-layer-version-by-arn --arn arn:aws:lambda:{aws::region}:094274105915:layer:AWSLambdaPowertoolsTypeScript:9 --region {region}\n</code></pre> <p>The pre-signed URL to download this Lambda Layer will be within <code>Location</code> key.</p>"},{"location":"#instrumentation","title":"Instrumentation","text":"<p>You can instrument your code with Powertools in three different ways:  </p> <ul> <li>Middy middleware. It is the best choice if your existing code base relies on the Middy middleware engine. Powertools offers compatible Middy middleware to make this integration seamless.</li> <li>Method decorator. Use TypeScript method decorators if you prefer writing your business logic using TypeScript Classes. If you aren\u2019t using Classes, this requires the most significant refactoring.</li> <li>Manually. It provides the most granular control. It\u2019s the most verbose approach, with the added benefit of no additional dependency and no refactoring to TypeScript Classes.</li> </ul> <p>The examples in this documentation will feature all the approaches described above, when applicable.</p>"},{"location":"#examples","title":"Examples","text":"<p>The project's repository includes examples of how to instrument your functions both in AWS CDK and AWS SAM:</p> <ul> <li>AWS CDK</li> <li>AWS SAM</li> </ul> <p>If instead you want to see Powertools for TypeScript in a slightly more complex use case, check the Serverless TypeScript Demo. You can find instructions on how to deploy and load test this application in the repository.</p>"},{"location":"#features","title":"Features","text":"<p>Core utilities such as Tracing, Logging, and Metrics will be available across all Lambda Powertools languages. Additional utilities are subjective to each language ecosystem and customer demand.</p>    Utility Description     Tracer Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions   Logger Structured logging made easier, and a middleware to enrich structured logging with key Lambda context details   Metrics Custom Metrics created asynchronously via CloudWatch Embedded Metric Format (EMF)"},{"location":"#environment-variables","title":"Environment variables","text":"Info <p>Explicit parameters take precedence over environment variables</p>     Environment variable Description Utility Default     POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All <code>service_undefined</code>   POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics <code>default_namespace</code>   POWERTOOLS_TRACE_ENABLED Explicitly disables tracing Tracer <code>true</code>   POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracer <code>true</code>   POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracer <code>true</code>   POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS Captures HTTP(s) requests as segments. Tracer <code>true</code>   POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logger <code>false</code>   POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logger <code>0</code>   POWERTOOLS_DEV Increase JSON indentation to ease debugging when running functions locally or in a non-production environment Logger <code>false</code>   LOG_LEVEL Sets logging level Logger <code>INFO</code>    <p>Each Utility page provides information on example values and allowed values</p>"},{"location":"#tenets","title":"Tenets","text":"<p>These are our core principles to guide our decision making.</p> <ul> <li>AWS Lambda only. We optimise for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices. The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean. Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility. New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community. We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Progressive. Utilities are designed to be incrementally adoptable for customers at any stage of their Serverless journey. They follow language idioms and their community\u2019s common practices.</li> </ul>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.</p>"},{"location":"changelog/#160-2023-03-02","title":"1.6.0 (2023-03-02)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>docs: logger bringYourOwnFormatter snippet #1253 (#1254) (fdbba32)</li> <li>hardcoded cdk version in <code>publish_layer.yaml</code> (#1232) (63a3909)</li> <li>logger: createChild not passing all parent's attributes (#1267) (84ab4b9)</li> <li>logger: middleware stores initial persistent attributes correctly (#1329) (6b32304)</li> <li>parameters: handle base64/binaries in transformer (#1326) (bb50c04)</li> <li>parameters: Tokenize attribute names in <code>DynamoDBProvider</code> (#1239) (f3e5ed7)</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>idempotency: Add function wrapper and decorator (#1262) (eacb1d9)</li> <li>layers: add new regions (#1322) (618613b)</li> <li>logger: make loglevel types stricter (#1313) (5af51d3)</li> <li>parameters: add support for custom AWS SDK v3 clients for providers (#1260) (3a8cfa0)</li> </ul>"},{"location":"changelog/#151-2023-01-13","title":"1.5.1 (2023-01-13)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>logger: logger throws TypeError when log item has BigInt value (#1201) (a09e4df)</li> <li>parameters: types in BaseProvider + added getMultiple alias to SecretsProvider (#1214) (32bd7e8)</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>parameters: AppConfigProvider (#1200) (fecedb9)</li> <li>parameters: DynamoDBProvider support (#1202) (db94850)</li> <li>parameters: SecretsProvider support (#1206) (02516b7)</li> <li>parameters: SSMProvider support (#1187) (2e4bb76)</li> </ul>"},{"location":"changelog/#150-2022-11-25","title":"1.5.0 (2022-11-25)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>logger: merge child logger options correctly (#1178) (cb91374)</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>idempotency: Add persistence layer and DynamoDB implementation (#1110) (0a6676a)</li> <li>logger: disable logs while testing with <code>jest --silent</code> in dev env (#1165) (6f0c307)</li> <li>logger: pretty printing logs in local and non-prod environment (#1141) (8d52660)</li> <li>parameters: added <code>BaseProvider</code> class (#1168) (d717a26)</li> </ul>"},{"location":"changelog/#141-2022-11-09","title":"1.4.1 (2022-11-09)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>metrics: store service name in defaultDimensions to avoid clearing it (#1146) (a979202)</li> </ul>"},{"location":"changelog/#140-2022-10-27","title":"1.4.0 (2022-10-27)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>metrics: metadata and dimensions not cleared on publish (#1129) (b209c30)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>all: moved EnvService to commons + exposed getXrayTraceId in tracer (#1123) (c8e3c15)</li> </ul>"},{"location":"changelog/#130-2022-10-17","title":"1.3.0 (2022-10-17)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>all: update version command to use lint-fix (#1119) (6f14fb3)</li> <li>captureColdStartMetric and throwOnEmptyMetrics when set to false was interpreted as true (#1090) (127aad4)</li> <li>captureMethod correctly detect method name when used with external decorators (#1109) (a574406)</li> <li>logger: wait for decorated method return before clearing out state (#1087) (133ed3c)</li> <li>ts-node version for layer-publisher (#1112) (ee243de)</li> </ul>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>idempotency: create initial class structure for function idempotency (#1086) (06fbaae)</li> <li>publish lib as Lambda Layer (#1095) (83f6efb)</li> <li>tracer: specify subsegment name when capturing class method (#1092) (d4174eb)</li> </ul>"},{"location":"changelog/#reverts","title":"Reverts","text":"<ul> <li>Revert \"chore(release): v1.3.0 [skip ci]\" (237b99f)</li> </ul>"},{"location":"changelog/#121-2022-08-25","title":"1.2.1 (2022-08-25)","text":"<p>Note: Version bump only for package aws-lambda-powertools-typescript</p>"},{"location":"changelog/#120-2022-08-23","title":"1.2.0 (2022-08-23)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>docs: docs published with incorrect version number + api docs missing after release (#1066) (8b8b25c)</li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>metrics:  increase maximum dimensions to 29 (#1072) (7b9a027)</li> <li>tracer: allow disabling result capture for decorators and middleware (#1065) (c3b9a37)</li> </ul>"},{"location":"changelog/#111-2022-08-18","title":"1.1.1 (2022-08-18)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>logger: decorated class methods cannot access <code>this</code> (#1060) (73990bb)</li> <li>tracer: decorated class methods cannot access <code>this</code> (#1055) (107fa04)</li> <li>workflow concurrency + leftover needs (#1054) (9ce180a)</li> </ul>"},{"location":"changelog/#110-2022-08-12","title":"1.1.0 (2022-08-12)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>layers: release process + remove duplicate code (#1052) (f653c06)</li> <li>logger: fix clearstate bug when lambda handler throws (#1045) (5ebd1cf)</li> <li>wrong scope in captureMethod (#1026) (1a06fed)</li> </ul>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>build: publish lib as a Lambda Layer (#884) (c3a20c6), closes #1031</li> </ul>"},{"location":"changelog/#102-2022-07-19","title":"1.0.2 (2022-07-19)","text":"<p>Note: Version bump only for package aws-lambda-powertools-typescript</p>"},{"location":"changelog/#101-2022-07-14","title":"1.0.1 (2022-07-14)","text":"<p>Note: Version bump only for package aws-lambda-powertools-typescript</p>"},{"location":"changelog/#0120-rc1-2022-07-14","title":"0.12.0-rc.1 (2022-07-14)","text":""},{"location":"changelog/#reverts_1","title":"Reverts","text":"<ul> <li>Revert \"build: bump lerna (#1014)\" (#1018) (623e12d), closes #1014 #1018</li> </ul>"},{"location":"changelog/#0120-rc0-2022-07-14","title":"0.12.0-rc.0 (2022-07-14)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>logger: POWERTOOLS_LOGGER_LOG_EVENT precedence is respected (#1015) (1cbb4db)</li> <li>tracer: capture method throws errors correctly (#1016) (fb85238)</li> </ul>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>tracer: auto disable when running inside amplify mock (#1010) (024d628)</li> </ul>"},{"location":"changelog/#reverts_2","title":"Reverts","text":"<ul> <li>Revert \"chore(release): v0.12.0-rc.0 [skip ci]\" (9397f1d)</li> <li>Revert \"chore(release): v0.12.0-rc.0 [skip ci]\" (#1017) (51c18da), closes #1017</li> </ul>"},{"location":"changelog/#0111-rc0-2022-06-24","title":"0.11.1-rc.0 (2022-06-24)","text":"<p>Note: Version bump only for package aws-lambda-powertools-typescript</p>"},{"location":"changelog/#0110-2022-06-23","title":"0.11.0 (2022-06-23)","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>logger: add clear state functionality (#902) (fa1dacb)</li> </ul>"},{"location":"changelog/#0100-2022-06-02","title":"0.10.0 (2022-06-02)","text":""},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>commons: rename tests subfolder to samples to avoid being deleted by tools such as node-prune (#882) (74ef816)</li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>all: nodejs16x support (#877) (d2b13c9)</li> <li>logger: add removeKeys functionality (#901) (a0f72c2)</li> </ul>"},{"location":"changelog/#091-2022-05-24","title":"0.9.1 (2022-05-24)","text":""},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>logger: enable logging of arbitrary objects (#883) (5d34854)</li> </ul>"},{"location":"changelog/#090-2022-05-16","title":"0.9.0 (2022-05-16)","text":""},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>added back fetch-depth: 0 (#812) (494c742)</li> <li>logger: add xray_trace_id to every log (#776) (11af21a)</li> <li>reintroduce token while checking out (#848) (cabef3e)</li> <li>removed token from remaining actions (#805) (4fd9ecb)</li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>examples: added sam example to workflows (#849) (93f1c7b)</li> </ul>"},{"location":"changelog/#081-2022-04-14","title":"0.8.1 (2022-04-14)","text":""},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>logger: change logging to use stdout (#748) (0781a47)</li> </ul>"},{"location":"changelog/#080-2022-04-08","title":"0.8.0 (2022-04-08)","text":""},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>added captureHTTPsRequest feature (#677) (5a36723)</li> </ul>"},{"location":"changelog/#072-2022-04-01","title":"0.7.2 (2022-04-01)","text":"<p>Note: Version bump only for package aws-lambda-powertools-typescript</p>"},{"location":"changelog/#071-2022-03-17","title":"0.7.1 (2022-03-17)","text":""},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>logger: enable sequential invocation in e2e test (#658) (800424b)</li> <li>logger: fix handling of additional log keys (#614) (8aab299)</li> <li>tracer, metrics: use polling instead of fixed wait in e2e tests (#654) (6d4ab75)</li> </ul>"},{"location":"changelog/#070-2022-03-08","title":"0.7.0 (2022-03-08)","text":""},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>logger: adopted Utility class &amp; updated unit tests (#550) (48f3487)</li> <li>metrics: adopted Utility class (#548) (672e6a8)</li> <li>tracer: adopted Utility class &amp; updated unit tests (#549) (3769a69)</li> </ul>"},{"location":"changelog/#060-2022-02-17","title":"0.6.0 (2022-02-17)","text":""},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>logger: fix logger attribute merging (#535) (8180be1)</li> </ul>"},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>commons: centralize cold start heuristic (#547) (4e4091f)</li> <li>logger: add e2e tests for logger (#529) (e736b65)</li> </ul>"},{"location":"changelog/#051-2022-02-09","title":"0.5.1 (2022-02-09)","text":""},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>tracer: properly return DynamoDB.DocumentClient (#528) (3559e7b)</li> </ul>"},{"location":"changelog/#reverts_3","title":"Reverts","text":"<ul> <li>Revert \"build(deps-dev): bump aws-cdk from 1.139.0 to 1.143.0 (#532)\" (#544) (e96c9ba), closes #532 #544</li> <li>Revert \"build(deps-dev): bump @aws-cdk/aws-lambda-nodejs from 1.139.0 to 1.143.0 (#531)\" (#545) (7dffbd8), closes #531 #545</li> </ul>"},{"location":"changelog/#050-2022-01-26","title":"0.5.0 (2022-01-26)","text":""},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>examples: fix errors in logger and metrics examples (#509) (c19b47c)</li> <li>logger|metrics: properly return decorated class (#489) (014c5bd)</li> </ul>"},{"location":"changelog/#features_14","title":"Features","text":"<ul> <li>Add codespaces/gitpod support (#485) (ed6f258)</li> <li>all: make <code>@middy/core</code> optional (#511) (1107f96)</li> <li>tracer: add support for capturing DynamoDB DocumentClient (#450) (621ae50)</li> </ul>"},{"location":"changelog/#040-2022-01-20","title":"0.4.0 (2022-01-20)","text":""},{"location":"changelog/#features_15","title":"Features","text":"<ul> <li>logger: JSDOCS support (#491) (cd2c2d9)</li> </ul>"},{"location":"changelog/#033-2022-01-17","title":"0.3.3 (2022-01-17)","text":""},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>lerna version not publishing all packages (#480) (0cabc3f)</li> </ul>"},{"location":"changelog/#032-2022-01-17","title":"0.3.2 (2022-01-17)","text":""},{"location":"changelog/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li>export LogFormatter + update docs (#479) (7f91566)</li> <li>updated CDK examples to remove old references &amp; improve comments (#439) (4cdaaea)</li> </ul>"},{"location":"changelog/#031-2022-01-14","title":"0.3.1 (2022-01-14)","text":""},{"location":"changelog/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li>all: fix latest release broken by change of npm pack result on common (#470) (2c3df93), closes #417</li> </ul>"},{"location":"changelog/#030-2022-01-14","title":"0.3.0 (2022-01-14)","text":""},{"location":"changelog/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li>build: Fix linting issue and add linting to the pre-push hook (#440) (e7bc53c)</li> <li>build: Update contributing.md and fix npm ci (#417) (279ad98), closes #415 #415</li> <li>metrics: Rename purgeStoredMetrics() function usage in CDK example (#424) (02f0eae)</li> <li>tracer: avoid throwing errors in manual instrumentation when running outside of AWS Lambda  (#442) (fd02acb)</li> </ul>"},{"location":"changelog/#features_16","title":"Features","text":"<ul> <li>all: Update to examples use released version (0.2.0) (#405) (d5e0620)</li> </ul>"},{"location":"changelog/#020-2022-01-05","title":"0.2.0 (2022-01-05)","text":""},{"location":"changelog/#features_17","title":"Features","text":"<ul> <li>tracer: beta release (#91 (https://github.com/awslabs/aws-lambda-powertools-python/issues/91))</li> <li>logger: beta release (#24 (https://github.com/awslabs/aws-lambda-powertools-python/issues/24))</li> <li>metrics: beta release (#25 (https://github.com/awslabs/aws-lambda-powertools-python/issues/25))</li> </ul>"},{"location":"changelog/#contributions","title":"Contributions","text":"<ul> <li>chore(ci): auto-label PR on semantic title (#403) by @heitorlessa</li> <li>fix: documentation generation on on-release.yml workflow (#368) by @ijemmy</li> <li>fix: Remove publishing doc on develop version and fix missing leading 0 in version (#356) by @ijemmy</li> <li>feat: generate new version of doc for each release (#355) by @ijemmy</li> <li>chore(cicd): cdk examples and e2e tests for metrics  (#326) by @flochaz</li> <li>fix(cicd): skip ci on bump commit (#339) by @flochaz</li> <li>chore(cicd): fix publish (#336) by @flochaz</li> <li>chore(cicd): Add release workflow (#260) by @flochaz</li> <li>chore(commons): Create a common package (#314) by @flochaz</li> <li>feat: Auto publish docs to version \"develop\" (#269) by @ijemmy</li> <li>fix(metrics): publish metrics even if handler throw (#249) by @flochaz</li> <li>chore: fix linting (#247) by @flochaz</li> <li>chore(all): npm libraries bump and breaking changes fixes (#215) by @saragerion</li> <li>chore: Enable auto-merge for dependabot PRs (#169) by @dreamorosi</li> <li>feat: add metrics (#102) by @alan-churley</li> <li>chore: Add commit hooks for testing and linting (#149) by @bahrmichael</li> <li>chore: Removed assignees from issue templates (#146) by @dreamorosi</li> <li>chore: Disabled auto-assign-issues integration (#144) by @dreamorosi</li> <li>feat: Adding sample automation for PR (#121) by @alan-churley</li> <li>test(logger): add unit tests with most important scenarios and features (#52) by @saragerion</li> <li>chore: increase version of WS dependancy (#71) by @alan-churley</li> <li>chore: dependancies upgrade (#70) by @alan-churley</li> <li>build(github-actions): fix YAML of closed issues message (#23) by @saragerion</li> <li>improv: repository documentation, metadata, github actions, dot files (#17) by @saragerion</li> <li>refactor(logger): overall improvements - DX, examples, business logic (#16) by @saragerion</li> <li>chore: updating path for coverage (#12) by @alan-churley</li> <li>feat(logger): add context decorator functionality (#13) by @saragerion</li> <li>test(all): add mock Lambda events payloads generated by other AWS services (#10) by @saragerion</li> <li>feat(logger): basic logger logic (#9) by @saragerion</li> <li>revert: Remove CodeQL analysis (#2) by @alan-churley</li> <li> <p>feat(metrics): rename method purgeStoredMetrics to publishStoredMetrics (#377) by @flochaz</p> </li> <li> <p>fix(metrics): use same naming for serviceName (#401) by @flochaz</p> </li> <li>feat(commons): update types to have optional callback (#394) by @flochaz</li> <li>feat(metrics): logMetrics middleware (#338) by @saragerion</li> <li>chore(tracer): quality of life improvements (#337) by @dreamorosi</li> <li>feat(tracer): middy middleware (#324) by @dreamorosi</li> <li>feat(logger): middy middleware (#313) by @saragerion</li> <li>chore(ALL): fix packaging (#316) by @flochaz</li> <li>feat: add tracer (#107) by @dreamorosi</li> <li>feat(logger): documentation, examples, business logic changes (#293) by @saragerion</li> <li>feat(metric): bring feature parity between decorator and utility function (#291) by @flochaz</li> <li>docs(all): make docs more coherent (#387) by @dreamorosi</li> <li>docs(logger): improve mkdocs and examples of sample rate feature (#389) by @saragerion</li> <li>docs(all): clarifications &amp; fixes  (#370) by @dreamorosi</li> <li>chore(tracer): cdk examples + e2e tests (#347) by @dreamorosi</li> <li>docs(all): getting started section, beta release warning (#351) by @saragerion</li> <li>chore(docs): Tracer docs (#274) by @dreamorosi</li> <li>chore(docs): Add credits section to README (#305) by @dreamorosi</li> <li>chore(metrics): Add typeDoc (#285) by @flochaz</li> <li>feat(logger): documentation, examples, business logic changes (#293) by @saragerion</li> <li>chore(metrics): github page doc (#284) by @flochaz</li> <li>feat: generate api docs (#277) by @ijemmy</li> <li>docs: base documentation (#250) by @dreamorosi</li> <li>docs: updating readme and package.json to work with lerna (#11) by @alan-churley</li> <li>fix(metrics): Support multiple addMetric() call with the same metric name (#390) by @ijemmy</li> <li>fix(logger): display correct log level in cloudwatch (#386) by @saragerion</li> <li>fix(metrics): expose logMetrics middleware (#380) by @flochaz</li> <li>chore: change license (#117) by @dreamorosi</li> <li>chore: don't bump version for merge to main (#404) by @flochaz</li> <li>feat(ALL): Use optional callback LambdaInterface for decorator (#397) by @flochaz</li> <li>chore(ci): add release drafter workflow (#382) by @heitorlessa</li> <li>build(deps): bump e2e dependencies metrics (#371) by @dreamorosi</li> <li>build(deps-dev): bump @aws-cdk/aws-lambda from 1.136.0 to 1.137.0 (#340) by @dependabot</li> <li>chore(commons): Remove eslint from commons pkg (#352) by @dreamorosi</li> <li>build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#335) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.11.11 to 17.0.0 (#325) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#318) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#317) by @dependabot</li> <li>build(deps-dev): bump jest from 27.4.3 to 27.4.5 (#310) by @dependabot</li> <li>build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.88 (#312) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.5.2 to 4.5.4 (#311) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.7.0 (#308) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.7.0 (#309) by @dependabot</li> <li>build(deps): bump aws-xray-sdk-core from 3.3.3 to 3.3.4 (#307) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#297) by @dependabot</li> <li>build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.87 (#299) by @dependabot</li> <li>build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#300) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#298) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#296) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.5.2 to 4.5.3 (#287) by @dependabot</li> <li>build(deps-dev): bump jest from 27.4.3 to 27.4.4 (#288) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.177 to 4.14.178 (#283) by @dependabot</li> <li>build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#272) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.7 to 27.1.1 (#271) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#270) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#273) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 5.5.0 to 5.6.0 (#268) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.11.11 to 16.11.12 (#267) by @dependabot</li> <li>build(deps-dev): bump eslint from 8.3.0 to 8.4.1 (#266) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 5.5.0 to 5.6.0 (#265) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.7 to 27.1.0 (#264) by @dependabot</li> <li>build(deps): bump @types/aws-lambda from 8.10.85 to 8.10.86 (#263) by @dependabot</li> <li>build(deps): bump romeovs/lcov-reporter-action from 0.2.21 to 0.3.1 (#261) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 27.0.2 to 27.0.3 (#258) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.11.6 to 16.11.11 (#257) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.33.0 to 5.5.0 (#256) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.175 to 4.14.177 (#255) by @dependabot</li> <li>build(deps): bump @types/aws-lambda from 8.10.84 to 8.10.85 (#252) by @dependabot</li> <li>build(deps-dev): bump jest from 27.3.1 to 27.4.3 (#251) by @dependabot</li> <li>build(deps-dev): bump husky from 7.0.2 to 7.0.4 (#243) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.33.0 to 5.5.0 (#253) by @dependabot</li> <li>build(deps-dev): bump eslint from 8.1.0 to 8.3.0 (#254) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.4.3 to 4.5.2 (#245) by @dependabot</li> <li>build(deps-dev): bump ts-node from 10.3.0 to 10.4.0 (#242) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.5 to 27.0.7 (#234) by @dependabot</li> <li>build(deps-dev): bump @commitlint/cli from 13.2.1 to 15.0.0 (#244) by @dependabot</li> <li>build(deps-dev): bump jest from 27.2.5 to 27.3.1 (#235) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.32.0 to 8.1.0 (#239) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.10.3 to 16.11.6 (#240) by @dependabot</li> <li>build(deps-dev): bump ts-node from 10.2.1 to 10.3.0 (#226) by @dependabot</li> <li>build(deps-dev): bump jest from 27.2.4 to 27.2.5 (#225) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.83 to 8.10.84 (#223) by @dependabot</li> <li>build(deps-dev): bump @commitlint/cli from 13.2.0 to 13.2.1 (#222) by @dependabot</li> <li>build(deps-dev): bump jest from 27.2.2 to 27.2.4 (#217) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.32.0 to 4.33.0 (#219) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.32.0 to 4.33.0 (#220) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.10.1 to 16.10.3 (#221) by @dependabot</li> <li>build(deps-dev): bump jest from 27.0.6 to 27.2.2 (#212) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.4 to 27.0.5 (#181) by @dependabot</li> <li>build(deps): bump actions/github-script from 4.1 to 5 (#211) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.3.5 to 4.4.3 (#199) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.9.6 to 16.10.1 (#213) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.173 to 4.14.174 (#214) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.9.4 to 16.9.6 (#210) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.30.0 to 4.31.2 (#209) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 27.0.1 to 27.0.2 (#208) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.9.2 to 16.9.4 (#205) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.31.1 to 4.31.2 (#206) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.9.1 to 16.9.2 (#204) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.172 to 4.14.173 (#203) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.7.2 to 16.9.1 (#202) by @dependabot</li> <li>build(deps-dev): bump husky from 7.0.1 to 7.0.2 (#191) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.29.2 to 4.31.1 (#200) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.2 to 4.30.0 (#194) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.6.2 to 16.7.2 (#190) by @dependabot</li> <li>build(deps): bump actions/github-script from 4.0.2 to 4.1 (#187) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.82 to 8.10.83 (#186) by @dependabot</li> <li>build(deps): bump actions/github-script from 3.1.0 to 4.0.2 (#179) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.1 to 4.29.2 (#180) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.6.1 to 16.6.2 (#184) by @dependabot</li> <li>build(deps-dev): bump ts-node from 10.2.0 to 10.2.1 (#183) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.29.1 to 4.29.2 (#182) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 27.0.0 to 27.0.1 (#177) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.6.0 to 16.6.1 (#176) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.13 to 16.6.0 (#174) by @dependabot</li> <li>build(deps-dev): bump @commitlint/cli from 12.1.4 to 13.1.0 (#172) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 26.0.24 to 27.0.0 (#171) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.81 to 8.10.82 (#170) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.29.0 to 4.29.1 (#167) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.29.0 to 4.29.1 (#166) by @dependabot</li> <li>improv: Use lodash.merge &amp; lodash.clonedeed instead of full lodash in Logger (#159) by @dreamorosi</li> <li>build(deps-dev): bump ts-node from 10.1.0 to 10.2.0 (#164) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.10 to 16.4.13 (#162) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.28.5 to 4.29.0 (#156) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.5 to 4.29.0 (#157) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.171 to 4.14.172 (#158) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.31.0 to 7.32.0 (#155) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.7 to 16.4.10 (#154) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.6 to 16.4.7 (#150) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.5 to 16.4.6 (#148) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.3 to 16.4.5 (#145) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.4 to 4.28.5 (#138) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.28.4 to 4.28.5 (#137) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.80 to 8.10.81 (#135) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.1 to 16.4.3 (#134) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.4.0 to 16.4.1 (#132) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.79 to 8.10.80 (#128) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 27.0.3 to 27.0.4 (#127) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.3.3 to 16.4.0 (#124) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.3 to 4.28.4 (#122) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.28.3 to 4.28.4 (#123) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.30.0 to 7.31.0 (#118) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.3.2 to 16.3.3 (#119) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.78 to 8.10.79 (#114) by @dependabot</li> <li>build(deps-dev): bump @types/node from 16.0.0 to 16.3.2 (#113) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.2 to 4.28.3 (#112) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.28.2 to 4.28.3 (#111) by @dependabot</li> <li>build(deps-dev): bump ts-node from 10.0.0 to 10.1.0 (#110) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.170 to 4.14.171 (#105) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 26.0.23 to 26.0.24 (#104) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.77 to 8.10.78 (#103) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.28.1 to 4.28.2 (#100) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.28.1 to 4.28.2 (#101) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.14.0 to 16.0.0 (#98) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.29.0 to 7.30.0 (#99) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.3.4 to 4.3.5 (#97) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.12.3 to 15.14.0 (#96) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.27.0 to 4.28.1 (#94) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.28.0 to 7.29.0 (#86) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.12.3 to 15.12.5 (#92) by @dependabot</li> <li>build(deps-dev): bump jest from 27.0.4 to 27.0.6 (#93) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.27.0 to 4.28.1 (#95) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.3.2 to 4.3.4 (#84) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.12.2 to 15.12.3 (#85) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.26.1 to 4.27.0 (#81) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.1 to 4.27.0 (#82) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.26.0 to 4.26.1 (#80) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.26.0 to 4.26.1 (#78) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.12.1 to 15.12.2 (#79) by @dependabot</li> <li>build(deps-dev): bump jest from 26.6.3 to 27.0.4 (#73) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.25.0 to 4.26.0 (#69) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.25.0 to 4.26.0 (#68) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.2.4 to 4.3.2 (#66) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.3.1 to 15.6.1 (#61) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.24.0 to 4.25.0 (#62) by @dependabot</li> <li>build(deps-dev): bump @types/lodash from 4.14.169 to 4.14.170 (#60) by @dependabot</li> <li>build(deps-dev): bump ts-node from 9.1.1 to 10.0.0 (#58) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.26.0 to 7.27.0 (#57) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.3.0 to 15.3.1 (#56) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.23.0 to 4.24.0 (#55) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.23.0 to 4.24.0 (#54) by @dependabot</li> <li>build(deps-dev): bump @types/node from 15.0.3 to 15.3.0 (#53) by @dependabot</li> <li>build(deps-dev): bump @types/node from 14.14.37 to 15.0.3 (#50) by @dependabot</li> <li>build(deps-dev): bump lerna from 3.22.1 to 4.0.0 (#29) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.21.0 to 4.22.0 (#37) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.23.0 to 7.24.0 (#35) by @dependabot</li> <li>build(deps): bump romeovs/lcov-reporter-action from v0.2.11 to v0.2.21 (#34) by @dependabot</li> <li>build(deps-dev): bump @commitlint/cli from 11.0.0 to 12.1.1 (#33) by @dependabot</li> <li>build(deps-dev): bump @types/aws-lambda from 8.10.72 to 8.10.75 (#32) by @dependabot</li> <li>build(deps-dev): bump @types/node from 14.14.20 to 14.14.37 (#31) by @dependabot</li> <li>build(deps-dev): bump husky from 4.3.7 to 6.0.0 (#30) by @dependabot</li> <li>build(deps-dev): bump typescript from 4.1.3 to 4.2.4 (#28) by @dependabot</li> <li>build(deps-dev): bump ts-jest from 26.4.4 to 26.5.4 (#27) by @dependabot</li> <li>build(deps-dev): bump eslint from 7.17.0 to 7.23.0 (#21) by @dependabot</li> <li>build(deps-dev): bump @types/jest from 26.0.20 to 26.0.22 (#22) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/parser from 4.13.0 to 4.21.0 (#20) by @dependabot</li> <li>build(deps-dev): bump @typescript-eslint/eslint-plugin from 4.13.0 to 4.21.0 (#18) by @dependabot</li> <li>build(deps-dev): bump @commitlint/config-conventional from 11.0.0 to 12.1.1 (#19) by @dependabot</li> <li>docs: updating readme and package.json to work with lerna (#11) by @alan-churley</li> <li>chore: lerna downstream dependancy security issues (#15) by @alan-churley</li> <li>build(deps): bump ini from 1.3.5 to 1.3.8 (#5) by @dependabot</li> <li>build(deps): bump ini from 1.3.5 to 1.3.8 in /packages/logging (#4) by @dependabot</li> <li>build(deps): bump ini from 1.3.5 to 1.3.8 in /docs (#3) by @dependabot</li> </ul>"},{"location":"changelog/#contributor-list","title":"Contributor List:","text":"<p>@alan-churley, @bahrmichael, @dreamorosi, @flochaz, @heitorlessa, @ijemmy and @saragerion</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#overview","title":"Overview","text":"<p>This is our public roadmap that outlines the high level direction we are working towards, namely Themes. We update this document when our priorities change: security and stability is our top priority.</p> <p>See our latest list of activities \u00bb</p>"},{"location":"roadmap/#themes","title":"Themes","text":"<p>Operational Excellence is priority number 1.</p>  <p>Themes are key activities maintainers are focusing on, besides bug reports. These are updated periodically and you can get an idea of the overall progress in the Milestones section.</p>"},{"location":"roadmap/#new-utilities","title":"New utilities","text":"<p>After going GA, we want to start working on new utilities, specifically but not limited to the most commonly asked: (1) Idempotency and (2) Parameters.</p>"},{"location":"roadmap/#lambda-layers","title":"Lambda Layers","text":"<p>We want to publish and maintain public Lambda Layers.</p> <p>Work on this area is mostly complete and layers are already available in all commercial regions, however we still have some work to do around automation.</p>"},{"location":"roadmap/#es-modules-support","title":"ES Modules support","text":"<p>Another one of the most requested features is ES Modules support. This topic requires some in-depth investigation to understand how to move forward and how to deal with some of our upstream dependencies.</p> <p>When the time comes, we might open a RFC to discuss options.</p>"},{"location":"roadmap/#improve-operational-excellence","title":"Improve operational excellence","text":"<p>We continue to work on increasing operational excellence to remove as much undifferentiated heavylifting for maintainers, so that we can focus on delivering features that help you.</p> <p>This means improving our automation workflows, and project management, and test coverage.</p>"},{"location":"roadmap/#roadmap-status-definition","title":"Roadmap status definition","text":"<p> <pre><code>graph LR\n    Ideas --&gt; Backlog --&gt; Work[\"Working on it\"] --&gt; Merged[\"Coming soon\"] --&gt; Shipped</code></pre> Visual representation </p> <p>Within our public board, you'll see the following values in the <code>Status</code> column:</p> <ul> <li>Ideas. Incoming and existing feature requests that are not being actively considered yet. These will be reviewed when bandwidth permits and based on demand.</li> <li>Backlog. Accepted feature requests or enhancements that we want to work on.</li> <li>Working on it. Features or enhancements we're currently either researching or implementing it.</li> <li>Coming soon. Any feature, enhancement, or bug fixes that have been merged and are coming in the next release.</li> <li>Shipped. Features or enhancements that are now available in the most recent release.</li> <li>On hold. Features or items that are currently blocked until further notice.</li> <li>Pending review. Features which implementation is mostly completed, but need review and some additional iterations.</li> </ul>  <p>Tasks or issues with empty <code>Status</code> will be categorized in upcoming review cycles.</p>"},{"location":"roadmap/#process","title":"Process","text":"<p> <pre><code>graph LR\n    PFR[Feature request] --&gt; Triage{Need RFC?}\n    Triage --&gt; |Complex/major change or new utility?| RFC[Ask or write RFC] --&gt; Approval{Approved?}\n    Triage --&gt; |Minor feature or enhancement?| NoRFC[No RFC required] --&gt; Approval\n    Approval --&gt; |Yes| Backlog\n    Approval --&gt; |No | Reject[\"Inform next steps\"]\n    Backlog --&gt; |Prioritized| Implementation\n    Backlog --&gt; |Defer| WelcomeContributions[\"help-wanted label\"]</code></pre> Visual representation </p> <p>Our end-to-end mechanism follows four major steps:</p> <ul> <li>Feature Request. Ideas start with a feature request to outline their use case at a high level. For complex use cases, maintainers might ask for/write a RFC.<ul> <li>Maintainers review requests based on project tenets, customers reaction (\ud83d\udc4d), and use cases.</li> </ul> </li> <li>Request-for-comments (RFC). Design proposals use our RFC issue template to describe its implementation, challenges, developer experience, dependencies, and alternative solutions.<ul> <li>This helps refine the initial idea with community feedback before a decision is made.</li> </ul> </li> <li>Decision. After carefully reviewing and discussing them, maintainers make a final decision on whether to start implementation, defer or reject it, and update everyone with the next steps.</li> <li>Implementation. For approved features, maintainers give priority to the original authors for implementation unless it is a sensitive task that is best handled by maintainers.</li> </ul>  See Maintainers document to understand how we triage issues and pull requests, labels and governance."},{"location":"roadmap/#disclaimer","title":"Disclaimer","text":"<p>The AWS Lambda Powertools team values feedback and guidance from its community of users, although final decisions on inclusion into the project will be made by AWS.</p> <p>We determine the high-level direction for our open roadmap based on customer feedback and popularity (\ud83d\udc4d\ud83c\udffd and comments), security and operational impacts, and business value. Where features don\u2019t meet our goals and longer-term strategy, we will communicate that clearly and openly as quickly as possible with an explanation of why the decision was made.</p>"},{"location":"roadmap/#faqs","title":"FAQs","text":"<p>Q: Why did you build this?</p> <p>A: We know that our customers are making decisions and plans based on what we are developing, and we want to provide our customers the insights they need to plan.</p> <p>Q: Why are there no dates on your roadmap?</p> <p>A: Because job zero is security and operational stability, we can't provide specific target dates for features. The roadmap is subject to change at any time, and roadmap issues in this repository do not guarantee a feature will be launched as proposed.</p> <p>Q: How can I provide feedback or ask for more information?</p> <p>A: For existing features, you can directly comment on issues. For anything else, please open an issue.</p>"},{"location":"core/logger/","title":"Logger","text":"<p>Logger provides an opinionated logger with output structured as JSON.</p>"},{"location":"core/logger/#key-features","title":"Key features","text":"<ul> <li>Capturing key fields from the Lambda context, cold starts, and structure logging output as JSON.</li> <li>Logging Lambda invocation events when instructed (disabled by default).</li> <li>Printing all the logs only for a percentage of invocations via log sampling (disabled by default).</li> <li>Appending additional keys to structured logs at any point in time.</li> <li>Providing a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with your organization\u2019s Logging RFC.</li> </ul>    Logger showcase - Log attributes"},{"location":"core/logger/#getting-started","title":"Getting started","text":""},{"location":"core/logger/#installation","title":"Installation","text":"<p>Install the library in your project:</p> <pre><code>npm install @aws-lambda-powertools/logger\n</code></pre>"},{"location":"core/logger/#usage","title":"Usage","text":"<p>The <code>Logger</code> utility must always be instantiated outside the Lambda handler. By doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, <code>Logger</code> can keep track of a cold start and inject the appropriate fields into logs.</p> handler.ts   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\nconst logger = new Logger({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event, _context): Promise&lt;void&gt; =&gt; {\n  logger.info('Hello World');\n};\n</code></pre>"},{"location":"core/logger/#utility-settings","title":"Utility settings","text":"<p>The library requires two settings. You can set them as environment variables, or pass them in the constructor.</p> <p>These settings will be used across all logs emitted:</p>    Setting Description Environment variable Default Value Allowed Values Example Value Constructor parameter     Service name Sets the name of service of which the Lambda function is part of, that will be present across all log statements <code>POWERTOOLS_SERVICE_NAME</code> <code>service_undefined</code> Any string <code>serverlessAirline</code> <code>serviceName</code>   Logging level Sets how verbose Logger should be, from the most verbose to the least verbose (no logs) <code>LOG_LEVEL</code> <code>info</code> <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>SILENT</code> <code>ERROR</code> <code>logLevel</code>   Log incoming event Whether to log or not the incoming event when using the decorator or middleware <code>POWERTOOLS_LOGGER_LOG_EVENT</code> <code>false</code> <code>true</code>, <code>false</code> <code>false</code> <code>logEvent</code>   Debug log sampling Probability that a Lambda invocation will print all the log items regardless of the log level setting <code>POWERTOOLS_LOGGER_SAMPLE_RATE</code> <code>0</code> <code>0.0</code> to <code>1</code> <code>0.5</code> <code>sampleRateValue</code>"},{"location":"core/logger/#example-using-aws-serverless-application-model-sam","title":"Example using AWS Serverless Application Model (SAM)","text":"handler.tstemplate.yaml   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\n// Logger parameters fetched from the environment variables (see template.yaml tab)\nconst logger = new Logger();\nlogger.info('Hello World');\n\n// You can also pass the parameters in the constructor\n// const logger = new Logger({\n//     logLevel: 'WARN',\n//     serviceName: 'serverlessAirline'\n// });\n</code></pre>   <pre><code>Resources:\n  ShoppingCartApiFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Runtime: nodejs16.x\n      Environment:\n        Variables:\n          LOG_LEVEL: WARN\n          POWERTOOLS_SERVICE_NAME: serverlessAirline\n</code></pre>"},{"location":"core/logger/#standard-structured-keys","title":"Standard structured keys","text":"<p>Your Logger will include the following keys to your structured logging (default log formatter):</p>    Key Example Note     level: <code>string</code> <code>INFO</code> Logging level set for the Lambda function's invocation   message: <code>string</code> <code>Query performed to DynamoDB</code> A descriptive, human-readable representation of this log item   sampling_rate: <code>float</code> <code>0.1</code> When enabled, it prints all the logs of a percentage of invocations, e.g. 10%   service: <code>string</code> <code>serverlessAirline</code> A unique name identifier of the service this Lambda function belongs to, by default <code>service_undefined</code>   timestamp: <code>string</code> <code>2011-10-05T14:48:00.000Z</code> Timestamp string in simplified extended ISO format (ISO 8601)   xray_trace_id: <code>string</code> <code>1-5759e988-bd862e3fe1be46a994272793</code> X-Ray Trace ID. This value is always presented in Lambda environment, whether tracing is enabled or not. Logger will always log this value.   error: <code>Object</code> <code>{ name: \"Error\", location: \"/my-project/handler.ts:18\", message: \"Unexpected error #1\", stack: \"[stacktrace]\"}</code> Optional - An object containing information about the Error passed to the logger     Info <p>When <code>POWERTOOLS_DEV</code> environment variable is present and set to <code>\"true\"</code> or <code>\"1\"</code>, Logger will pretty-print log messages for easier readability. We recommend to use this setting only when debugging on local environments.</p>"},{"location":"core/logger/#capturing-lambda-context-info","title":"Capturing Lambda context info","text":"<p>You can enrich your structured logs with key Lambda context information in multiple ways.</p> <p>This functionality will include the following keys in your structured logs:</p>    Key Example     cold_start: <code>bool</code> <code>false</code>   function_name <code>string</code> <code>shopping-cart-api-lambda-prod-eu-west-1</code>   function_memory_size: <code>number</code> <code>128</code>   function_arn: <code>string</code> <code>arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1</code>   function_request_id: <code>string</code> <code>c6af9ac6-7b61-11e6-9a41-93e812345678</code>    Middy MiddlewareDecoratorManual    <p>Using Middy for the first time?</p> <p>You can install Middy by running <code>npm i @middy/core</code>. Learn more about its usage and lifecycle in the official Middy documentation.</p>  <pre><code>import { Logger, injectLambdaContext } from '@aws-lambda-powertools/logger';\nimport middy from '@middy/core';\n\nconst logger = new Logger();\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  logger.info('This is an INFO log with some context');\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(injectLambdaContext(logger));\n</code></pre>   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst logger = new Logger();\n\nclass Lambda implements LambdaInterface {\n  // Decorate your handler class method\n  @logger.injectLambdaContext()\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    logger.info('This is an INFO log with some context');\n  }\n\n}\n\nconst myFunction = new Lambda();\nexport const handler = myFunction.handler.bind(myFunction); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\nconst logger = new Logger();\n\nexport const handler = async (_event, context): Promise&lt;void&gt; =&gt; {\n\n  logger.addContext(context);\n\n  logger.info('This is an INFO log with some context');\n\n};\n</code></pre>    <p>In each case, the printed log will look like this:</p> Example CloudWatch Logs excerpt   <pre><code>{\n    \"cold_start\": true,\n    \"function_arn\": \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\",\n    \"function_memory_size\": 128,\n    \"function_request_id\": \"c6af9ac6-7b61-11e6-9a41-93e812345678\",\n    \"function_name\": \"shopping-cart-api-lambda-prod-eu-west-1\",\n    \"level\": \"INFO\",\n    \"message\": \"This is an INFO log with some context\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T21:21:08.921Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>"},{"location":"core/logger/#log-incoming-event","title":"Log incoming event","text":"<p>When debugging in non-production environments, you can instruct Logger to log the incoming event with the middleware/decorator parameter <code>logEvent</code> or via <code>POWERTOOLS_LOGGER_LOG_EVENT</code> env var set to <code>true</code>.</p>  Warning <p>This is disabled by default to prevent sensitive info being logged</p>  Middy MiddlewareDecorator   <pre><code>import { Logger, injectLambdaContext } from '@aws-lambda-powertools/logger';\nimport middy from '@middy/core';\n\nconst logger = new Logger();\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  logger.info('This is an INFO log with some context');\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(injectLambdaContext(logger, { logEvent: true }));\n</code></pre>   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst logger = new Logger();\n\nclass Lambda implements LambdaInterface {\n  // Set the log event flag to true\n  @logger.injectLambdaContext({ logEvent: true })\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    logger.info('This is an INFO log with some context');\n  }\n\n}\n\nconst myFunction = new Lambda();\nexport const handler = myFunction.handler.bind(myFunction); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>"},{"location":"core/logger/#appending-persistent-additional-log-keys-and-values","title":"Appending persistent additional log keys and values","text":"<p>You can append additional persistent keys and values in the logs generated during a Lambda invocation using either mechanism:</p> <ul> <li>Via the Logger's <code>appendKeys</code> method, for all log items generated after calling this method</li> <li>Passing them in the Logger's constructor</li> </ul> <p>To remove the keys you added, you can use the <code>removeKeys</code> method.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\n// Add persistent log keys via the constructor\nconst logger = new Logger({\n  persistentLogAttributes: { \n    aws_account_id: '123456789012',\n    aws_region: 'eu-west-1',\n    logger: {\n      name: '@aws-lambda-powertools/logger',\n      version: '0.0.1',\n    },\n    extra_key: 'some-value'\n  }\n});\n\n// OR add persistent log keys to an existing Logger instance with the appendKeys method:\n// logger.appendKeys({\n//     aws_account_id: '123456789012',\n//     aws_region: 'eu-west-1',\n//     logger: {\n//         name: '@aws-lambda-powertools/logger',\n//         version: '0.0.1',\n//     },\n//     extra_key: \"some-value\"\n// });    \n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;unknown&gt; =&gt; {\n\n  // If you don't want to log the \"extra_key\" attribute in your logs, you can remove it\n  logger.removeKeys(['extra_key']);\n\n  // This info log will print all extra custom attributes added above\n  // Extra attributes: logger object with name and version of the logger library, awsAccountId, awsRegion\n  logger.info('This is an INFO log');\n  logger.info('This is another INFO log');\n\n  return {\n    foo: 'bar'\n  };\n\n};\n</code></pre>   <pre><code>{\n    \"level\": \"INFO\",\n    \"message\": \"This is an INFO log\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T21:49:58.084Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"aws_account_id\": \"123456789012\",\n    \"aws_region\": \"eu-west-1\",\n    \"logger\": { \n        \"name\": \"@aws-lambda-powertools/logger\",\n        \"version\": \"0.0.1\"\n    }\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is another INFO log\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T21:49:58.088Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"aws_account_id\": \"123456789012\",\n    \"aws_region\": \"eu-west-1\",\n    \"logger\": { \n        \"name\": \"@aws-lambda-powertools/logger\",\n        \"version\": \"0.0.1\"\n    }\n}\n</code></pre>     <p>Logger will automatically ignore any key with an <code>undefined</code> value</p>"},{"location":"core/logger/#clearing-all-state","title":"Clearing all state","text":"<p>The Logger utility is commonly initialized in the global scope, outside the handler function. When you attach persistent log attributes through the <code>persistentLogAttributes</code> constructor option or via the <code>appendKeys</code>, <code>addPersistentLogAttributes</code> methods, this data is attached to the Logger instance.  </p> <p>Due to the Lambda Execution Context reuse, this means those persistent log attributes may be reused across invocations. If you want to make sure that persistent attributes added inside the handler function code are not persisted across invocations, you can set the parameter <code>clearState</code> as <code>true</code>  in the <code>injectLambdaContext</code> middleware or decorator.</p> Middy MiddlewareDecorator   <pre><code>import { Logger, injectLambdaContext } from '@aws-lambda-powertools/logger';\nimport middy from '@middy/core';\n\n// Persistent attributes added outside the handler will be \n// cached across invocations\nconst logger = new Logger({\n  logLevel: 'DEBUG',\n  persistentLogAttributes: {\n    foo: 'bar',\n    biz: 'baz'\n  }\n});\n\nconst lambdaHandler = async (event: { special_key: string }, _context: unknown): Promise&lt;void&gt; =&gt; {\n  // Persistent attributes added inside the handler will NOT be cached\n  // across invocations\n  if (event['special_key'] === '123456') {\n    logger.appendKeys({\n      details: { special_key: event['special_key'] }\n    });\n  }\n  logger.debug('This is a DEBUG log');\n};\n\n// Enable the clear state flag\nexport const handler = middy(lambdaHandler)\n  .use(injectLambdaContext(logger, { clearState: true }));\n</code></pre>   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\n// Persistent attributes added outside the handler will be \n// cached across invocations\nconst logger = new Logger({\n  logLevel: 'DEBUG',\n  persistentLogAttributes: {\n    foo: 'bar',\n    biz: 'baz'\n  }\n});\n\nclass Lambda implements LambdaInterface {\n  // Enable the clear state flag\n  @logger.injectLambdaContext({ clearState: true })\n  public async handler(event: unknown, _context: unknown): Promise&lt;void&gt; {\n    // Persistent attributes added inside the handler will NOT be cached\n    // across invocations\n    if (event['special_key'] === '123456'){\n      logger.appendKeys({\n        details: { special_key: '123456' }\n      });\n    }\n    logger.debug('This is a DEBUG log');\n  }\n\n}\n\nconst myFunction = new Lambda();\nexport const handler = myFunction.handler.bind(myFunction); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>    <p>In each case, the printed log will look like this:</p> First invocationSecond invocation   <pre><code>{\n    \"biz\": \"baz\",\n    \"cold_start\": true,\n    \"details\": {\n        \"special_key\": \"123456\",\n    },\n    \"foo\": \"bar\",\n    \"function_arn\": \"arn:aws:lambda:eu-west-1:123456789012:function:foo-bar-function\",\n    \"function_memory_size\": 128,\n    \"function_name\": \"foo-bar-function\",\n    \"function_request_id\": \"abcdef123456abcdef123456\",\n    \"level\": \"DEBUG\",\n    \"message\": \"This is a DEBUG log with the user_id\",\n    \"service\": \"hello-world\",\n    \"timestamp\": \"2021-12-12T22:32:54.670Z\",\n    \"xray_trace_id\": \"1-5759e988-bd862e3fe1be46a994272793\"\n}\n</code></pre>   <pre><code>{\n    \"biz\": \"baz\",\n    \"cold_start\": false,\n    \"foo\": \"bar\",\n    \"function_arn\": \"arn:aws:lambda:eu-west-1:123456789012:function:foo-bar-function\",\n    \"function_memory_size\": 128,\n    \"function_name\": \"foo-bar-function\",\n    \"function_request_id\": \"abcdef123456abcdef123456\",\n    \"level\": \"DEBUG\",\n    \"message\": \"This is a DEBUG log with the user_id\",\n    \"service\": \"hello-world\",\n    \"timestamp\": \"2021-12-12T22:40:23.120Z\",\n    \"xray_trace_id\": \"1-5759e988-bd862e3fe1be46a994272793\"\n}\n</code></pre>"},{"location":"core/logger/#appending-additional-data-to-a-single-log-item","title":"Appending additional data to a single log item","text":"<p>You can append additional data to a single log item by passing objects as additional parameters.</p> <ul> <li>Pass a simple string for logging it with default key name <code>extra</code></li> <li>Pass one or multiple objects containing arbitrary data to be logged. Each data object should be placed in an enclosing object as a single property value, you can name this property as you need: <code>{ myData: arbitraryObjectToLog }</code></li> <li>If you already have an object containing a <code>message</code> key and an additional property, you can pass this object directly</li> </ul> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\nconst logger = new Logger();\n\nexport const handler = async (event: unknown, _context: unknown): Promise&lt;unknown&gt; =&gt; {\n\n  const myImportantVariable = {\n    foo: 'bar'\n  };\n\n  // Log additional data in single log items\n\n  // As second parameter\n  logger.info('This is a log with an extra variable', { data: myImportantVariable });\n\n  // You can also pass multiple parameters containing arbitrary objects\n  logger.info('This is a log with 3 extra objects',\n    { data: myImportantVariable },\n    { correlationIds: { myCustomCorrelationId: 'foo-bar-baz' } },\n    { lambdaEvent: event }\n  );\n\n  // Simply pass a string for logging additional data\n  logger.info('This is a log with additional string value', 'string value');\n\n  // Directly passing an object containing both the message and the additional info\n  const logObject = {\n    message: 'This is a log message',\n    additionalValue: 42\n  };\n\n  logger.info(logObject);\n\n  return {\n    foo: 'bar'\n  };\n\n};\n</code></pre>   <pre><code>{\n    \"level\": \"INFO\",\n    \"message\": \"This is a log with an extra variable\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:06:17.463Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"data\": { \"foo\": \"bar\" }\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is a log with 3 extra objects\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:06:17.466Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"data\": { \"foo\": \"bar\" },\n    \"correlationIds\": { \"myCustomCorrelationId\": \"foo-bar-baz\" },\n    \"lambdaEvent\": { \n        \"exampleEventData\": {\n            \"eventValue\": 42\n        }\n    }\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is a log with additional string value\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:06:17.463Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"extra\": \"string value\"\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is a log message\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:06:17.463Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"additionalValue\": 42\n}\n</code></pre>"},{"location":"core/logger/#logging-errors","title":"Logging errors","text":"<p>You can log errors by using the <code>error</code> method and pass the error object as parameter. The error will be logged with default key name <code>error</code>, but you can also pass your own custom key name.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\nconst logger = new Logger();\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n\n  try {\n    throw new Error('Unexpected error #1');\n  } catch (error) {\n    // Log information about the error using the default \"error\" key\n    logger.error('This is the first error', error as Error);\n  }\n\n  try {\n    throw new Error('Unexpected error #2');\n  } catch (error) {\n    // Log information about the error using a custom \"myCustomErrorKey\" key\n    logger.error('This is the second error', { myCustomErrorKey: error as Error } );\n  }\n\n};\n</code></pre>   <pre><code>{\n    \"level\": \"ERROR\",\n    \"message\": \"This is the first error\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:12:39.345Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"error\": {\n        \"name\": \"Error\",\n        \"location\": \"/path/to/my/source-code/my-service/handler.ts:18\",\n        \"message\": \"Unexpected error #1\",\n        \"stack\": \"Error: Unexpected error #1    at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:18:11)    at Object.&lt;anonymous&gt; (/path/to/my/source-code/my-service/handler.ts:35:1)    at Module._compile (node:internal/modules/cjs/loader:1108:14)    at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23)    at Module._extensions..js (node:internal/modules/cjs/loader:1137:10)    at Object.require.extensions.&lt;computed&gt; [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12)    at Module.load (node:internal/modules/cjs/loader:973:32)    at Function.Module._load (node:internal/modules/cjs/loader:813:14)    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12)    at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\"\n    }\n}\n{   \n    \"level\": \"ERROR\",\n    \"message\": \"This is the second error\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:12:39.377Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\",\n    \"myCustomErrorKey\": {\n        \"name\": \"Error\",\n        \"location\": \"/path/to/my/source-code/my-service/handler.ts:24\",\n        \"message\": \"Unexpected error #2\",\n        \"stack\": \"Error: Unexpected error #2    at lambdaHandler (/path/to/my/source-code/my-service/handler.ts:24:11)    at Object.&lt;anonymous&gt; (/path/to/my/source-code/my-service/handler.ts:35:1)    at Module._compile (node:internal/modules/cjs/loader:1108:14)    at Module.m._compile (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1371:23)    at Module._extensions..js (node:internal/modules/cjs/loader:1137:10)    at Object.require.extensions.&lt;computed&gt; [as .ts] (/path/to/my/source-code/node_modules/ts-node/src/index.ts:1374:12)    at Module.load (node:internal/modules/cjs/loader:973:32)    at Function.Module._load (node:internal/modules/cjs/loader:813:14)    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12)    at main (/path/to/my/source-code/node_modules/ts-node/src/bin.ts:331:12)\"\n    }\n}\n</code></pre>     <p>Logging errors and log level</p> <p>You can also log errors using the <code>warn</code>, <code>info</code>, and <code>debug</code> methods. Be aware of the log level though, you might miss those  errors when analyzing the log later depending on the log level configuration.</p>"},{"location":"core/logger/#advanced","title":"Advanced","text":""},{"location":"core/logger/#using-multiple-logger-instances-across-your-code","title":"Using multiple Logger instances across your code","text":"<p>The <code>createChild</code> method allows you to create a child instance of the Logger, which inherits all of the attributes from its parent. You have the option to override any of the settings and attributes from the parent logger, including its settings, any persistent attributes, and the log formatter. Once a child logger is created, the logger and its parent will act as separate instances of the Logger class, and as such any change to one won't be applied to the other. </p> <p>The following example shows how to create multiple Loggers that share service name and persistent attributes while specifying different logging levels within a single Lambda invocation. As the result, only ERROR logs with all the inherited attributes will be displayed in CloudWatch Logs from the child logger, but all logs emitted will have the same service name and persistent attributes.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\n// This logger has a service name, some persistent attributes\n// and log level set to INFO\nconst logger = new Logger({\n  serviceName: 'serverlessAirline',\n  logLevel: 'INFO',\n  persistentLogAttributes: { \n    aws_account_id: '123456789012',\n    aws_region: 'eu-west-1',\n  },\n});\n\n// This other logger inherits all the parent's attributes \n// but the log level, which is now set to ERROR\nconst childLogger = logger.createChild({\n  logLevel: 'ERROR'\n});\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n\n  logger.info('This is an INFO log, from the parent logger');\n  logger.error('This is an ERROR log, from the parent logger');\n\n  childLogger.info('This is an INFO log, from the child logger');\n  childLogger.error('This is an ERROR log, from the child logger');\n\n};\n</code></pre>   <pre><code>{\n    \"level\": \"INFO\",\n    \"message\": \"This is an INFO log, from the parent logger\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:32:54.667Z\",\n    \"aws_account_id\":\"123456789012\",\n    \"aws_region\":\"eu-west-1\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log, from the parent logger\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:32:54.670Z\",\n    \"aws_account_id\":\"123456789012\",\n    \"aws_region\":\"eu-west-1\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log, from the child logger\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:32:54.670Z\",\n    \"aws_account_id\":\"123456789012\",\n    \"aws_region\":\"eu-west-1\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>"},{"location":"core/logger/#sampling-logs","title":"Sampling logs","text":"<p>Use sampling when you want to print all the log items generated in your code, based on a percentage of your concurrent/cold start invocations.</p> <p>You can do that by setting a \"sample rate\", a float value ranging from <code>0.0</code> (0%) to <code>1</code> (100%), by using a <code>POWERTOOLS_LOGGER_SAMPLE_RATE</code> env var or passing the <code>sampleRateValue</code> parameter in the Logger constructor. This number represents the probability that a Lambda invocation will print all the log items regardless of the log level setting.</p> <p>For example, by setting the \"sample rate\" to <code>0.5</code>, roughly 50% of your lambda invocations will print all the log items, including the <code>debug</code> ones.</p>  <p>When is this useful?</p> <p>In production, to avoid log data pollution and reduce CloudWatch costs, developers are encouraged to use the logger with <code>logLevel</code> equal to <code>ERROR</code> or <code>WARN</code>. This means that only errors or warnings will be printed.</p> <p>However, it might still be useful to print all the logs (including debug ones) of a very small percentage of invocations to have a better understanding of the behaviour of your code in production even when there are no errors.</p> <p>Sampling decision happens at the Logger initialization. This means sampling may happen significantly more or less than depending on your traffic patterns, for example a steady low number of invocations and thus few cold starts.</p>  handler.tsExample CloudWatch Logs excerpt - Invocation #1Example CloudWatch Logs excerpt - Invocation #2Example CloudWatch Logs excerpt - Invocation #3Example CloudWatch Logs excerpt - Invocation #4   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\n\n// Notice the log level set to 'ERROR'\nconst logger = new Logger({\n  logLevel: 'ERROR',\n  sampleRateValue: 0.5\n});\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n\n  // This log item (equal to log level 'ERROR') will be printed to standard output\n  // in all Lambda invocations\n  logger.error('This is an ERROR log');\n\n  // These log items (below the log level 'ERROR') have ~50% chance \n  // of being printed in a Lambda invocation\n  logger.debug('This is a DEBUG log that has 50% chance of being printed');\n  logger.info('This is an INFO log that has 50% chance of being printed');\n  logger.warn('This is a WARN log that has 50% chance of being printed');\n\n  // Optional: refresh sample rate calculation on runtime\n  // logger.refreshSampleRateCalculation();\n\n};\n</code></pre>   <pre><code>{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log\",\n    \"sampling_rate\": \"0.5\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.334Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"DEBUG\",\n    \"message\": \"This is a DEBUG log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.337Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is an INFO log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.338Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"WARN\",\n    \"message\": \"This is a WARN log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.338Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>   <pre><code>{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log\",\n    \"sampling_rate\": \"0.5\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.334Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>   <pre><code>{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log\",\n    \"sampling_rate\": \"0.5\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.334Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"DEBUG\",\n    \"message\": \"This is a DEBUG log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.337Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"INFO\",\n    \"message\": \"This is an INFO log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.338Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n{\n    \"level\": \"WARN\",\n    \"message\": \"This is a WARN log that has 50% chance of being printed\",\n    \"sampling_rate\": \"0.5\", \n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.338Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>   <pre><code>{\n    \"level\": \"ERROR\",\n    \"message\": \"This is an ERROR log\",\n    \"sampling_rate\": \"0.5\",\n    \"service\": \"serverlessAirline\",\n    \"timestamp\": \"2021-12-12T22:59:06.334Z\",\n    \"xray_trace_id\": \"abcdef123456abcdef123456abcdef123456\"\n}\n</code></pre>"},{"location":"core/logger/#silencing-logs","title":"Silencing logs","text":"<p>The <code>SILENT</code> log level provides a simple and efficient way to suppress all log messages without the need to modify your code. When you set this log level, all log messages, regardless of their severity, will be silenced.</p> <p>This feature is useful when you want to have your code instrumented to produce logs, but due to some requirement or business decision, you prefer to not emit them.</p> <p>By setting the log level to <code>SILENT</code>, which can be done either through the <code>logLevel</code> constructor option  or by using the <code>LOG_LEVEL</code> environment variable, you can easily suppress all logs as needed.</p>  <p>Note</p> <p>Use the <code>SILENT</code> log level with care, as it can make it more challenging to monitor and debug your application. Therefore, we advise using this log level judiciously.</p>"},{"location":"core/logger/#custom-log-formatter-bring-your-own-formatter","title":"Custom Log formatter (Bring Your Own Formatter)","text":"<p>You can customize the structure (keys and values) of your log items by passing a custom log formatter, an object that implements the <code>LogFormatter</code> abstract class.</p> handler.ts   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\nimport { MyCompanyLogFormatter } from './utils/formatters/MyCompanyLogFormatter';\n\nconst logger = new Logger({\n  logFormatter: new MyCompanyLogFormatter(),\n  logLevel: 'DEBUG',\n  serviceName: 'serverlessAirline',\n  sampleRateValue: 0.5,\n  persistentLogAttributes: {\n    awsAccountId: process.env.AWS_ACCOUNT_ID,\n    logger: {\n      name: '@aws-lambda-powertools/logger',\n      version: '0.0.1'\n    }\n  },\n});\n\nexport const handler = async (event, context): Promise&lt;void&gt; =&gt; {\n\n  logger.addContext(context);\n\n  logger.info('This is an INFO log', { correlationIds: { myCustomCorrelationId: 'foo-bar-baz' } });\n\n};\n</code></pre>    <p>This is how the <code>MyCompanyLogFormatter</code> (dummy name) would look like:</p> utils/formatters/MyCompanyLogFormatter.ts   <pre><code>import { LogFormatter } from '@aws-lambda-powertools/logger';\nimport {\n  LogAttributes,\n  UnformattedAttributes,\n} from '@aws-lambda-powertools/logger/lib/types';\n\n// Replace this line with your own type\ntype MyCompanyLog = LogAttributes;\n\nclass MyCompanyLogFormatter extends LogFormatter {\n  public formatAttributes(attributes: UnformattedAttributes): MyCompanyLog {\n    return {\n      message: attributes.message,\n      service: attributes.serviceName,\n      environment: attributes.environment,\n      awsRegion: attributes.awsRegion,\n      correlationIds: {\n        awsRequestId: attributes.lambdaContext?.awsRequestId,\n        xRayTraceId: attributes.xRayTraceId,\n      },\n      lambdaFunction: {\n        name: attributes.lambdaContext?.functionName,\n        arn: attributes.lambdaContext?.invokedFunctionArn,\n        memoryLimitInMB: attributes.lambdaContext?.memoryLimitInMB,\n        version: attributes.lambdaContext?.functionVersion,\n        coldStart: attributes.lambdaContext?.coldStart,\n      },\n      logLevel: attributes.logLevel,\n      timestamp: this.formatTimestamp(attributes.timestamp), // You can extend this function\n      logger: {\n        sampleRateValue: attributes.sampleRateValue,\n      },\n    };\n  }\n}\n\nexport { MyCompanyLogFormatter };\n</code></pre>    <p>This is how the printed log would look:</p> Example CloudWatch Logs excerpt   <pre><code>    {\n        \"message\": \"This is an INFO log\",\n        \"service\": \"serverlessAirline\",\n        \"awsRegion\": \"eu-west-1\",\n        \"correlationIds\": {\n            \"awsRequestId\": \"c6af9ac6-7b61-11e6-9a41-93e812345678\",\n            \"xRayTraceId\": \"abcdef123456abcdef123456abcdef123456\",\n            \"myCustomCorrelationId\": \"foo-bar-baz\"\n        },\n        \"lambdaFunction\": {\n            \"name\": \"shopping-cart-api-lambda-prod-eu-west-1\",\n            \"arn\": \"arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1\",\n            \"memoryLimitInMB\": 128,\n            \"version\": \"$LATEST\",\n            \"coldStart\": true\n        },\n        \"logLevel\": \"INFO\",\n        \"timestamp\": \"2021-12-12T23:13:53.404Z\",\n        \"logger\": {\n            \"sampleRateValue\": \"0.5\",\n            \"name\": \"aws-lambda-powertools-typescript\",\n            \"version\": \"0.0.1\"\n        },\n        \"awsAccountId\": \"123456789012\"\n    }\n</code></pre>     <p>Custom Log formatter and Child loggers</p> <p>It is not necessary to pass the <code>LogFormatter</code> each time a child logger is created. The parent's LogFormatter will be inherited by the child logger.</p>"},{"location":"core/logger/#testing-your-code","title":"Testing your code","text":""},{"location":"core/logger/#inject-lambda-context","title":"Inject Lambda Context","text":"<p>When unit testing your code that makes use of <code>logger.addContext()</code> or <code>injectLambdaContext</code> middleware and decorator, you can optionally pass a dummy Lambda Context if you want your logs to contain this information.</p> <p>This is a Jest sample that provides the minimum information necessary for Logger to inject context data:</p> handler.test.ts   <pre><code>import { ContextExamples as dummyContext } from '@aws-lambda-powertools/commons';\n\ndescribe('MyUnitTest', () =&gt; {\n\n  test('Lambda invoked successfully', async () =&gt; {\n\n    const testEvent = { test: 'test' };\n    await handler(testEvent, dummyContext);\n\n  });\n\n});\n</code></pre>     <p>Tip</p> <p>If you don't want to declare your own dummy Lambda Context, you can use <code>ContextExamples.helloworldContext</code> from <code>@aws-lambda-powertools/commons</code>.</p>"},{"location":"core/logger/#suppress-logs-with-jest","title":"Suppress logs with Jest","text":"<p>When unit testing your code with Jest you can use the <code>POWERTOOLS_DEV</code> environment variable in conjunction with the Jest <code>--silent</code> CLI option to suppress logs from Logger.</p> Disabling logs while testing with Jest<pre><code>export POWERTOOLS_DEV=true &amp;&amp; npx jest --silent\n</code></pre>"},{"location":"core/metrics/","title":"Metrics","text":"<p>Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF).</p> <p>These metrics can be visualized through Amazon CloudWatch Console.</p>"},{"location":"core/metrics/#key-features","title":"Key features","text":"<ul> <li>Aggregating up to 100 metrics using a single CloudWatch EMF object (large JSON blob).</li> <li>Validating your metrics against common metric definitions mistakes (for example, metric unit, values, max dimensions, max metrics).</li> <li>Metrics are created asynchronously by the CloudWatch service. You do not need any custom stacks, and there is no impact to Lambda function latency.</li> <li>Creating a one-off metric with different dimensions.</li> </ul>    Metrics showcase - Metrics Explorer"},{"location":"core/metrics/#terminologies","title":"Terminologies","text":"<p>If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility:</p> <ul> <li>Namespace. It's the highest level container that will group multiple metrics from multiple services for a given application, for example <code>ServerlessEcommerce</code>.</li> <li>Dimensions. Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example <code>ColdStart</code> metric by Payment <code>service</code>.</li> <li>Metric. It's the name of the metric, for example: SuccessfulBooking or UpdatedBooking.</li> <li>Unit. It's a value representing the unit of measure for the corresponding metric, for example: Count or Seconds.</li> <li>Resolution. It's a value representing the storage resolution for the corresponding metric. Metrics can be either Standard or High resolution. Read more here.</li> </ul>   Metric terminology, visually explained"},{"location":"core/metrics/#getting-started","title":"Getting started","text":""},{"location":"core/metrics/#installation","title":"Installation","text":"<p>Install the library in your project:</p> <pre><code>npm install @aws-lambda-powertools/metrics\n</code></pre>"},{"location":"core/metrics/#usage","title":"Usage","text":"<p>The <code>Metrics</code> utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, <code>Metrics</code> can track cold start and emit the appropriate metrics.</p> handler.ts   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n</code></pre>"},{"location":"core/metrics/#utility-settings","title":"Utility settings","text":"<p>The library requires two settings. You can set them as environment variables, or pass them in the constructor.  </p> <p>These settings will be used across all metrics emitted:</p>    Setting Description Environment variable Default Allowed Values Example Constructor parameter     Service Optionally, sets service metric dimension across all metrics <code>POWERTOOLS_SERVICE_NAME</code> <code>service_undefined</code> Any string <code>serverlessAirline</code> <code>serviceName</code>   Metric namespace Logical container where all metrics will be placed <code>POWERTOOLS_METRICS_NAMESPACE</code> <code>default_namespace</code> Any string <code>serverlessAirline</code> <code>default_namespace</code>     <p>Tip</p> <p>Use your application name or main service as the metric namespace to easily group all metrics</p>"},{"location":"core/metrics/#example-using-aws-serverless-application-model-sam","title":"Example using AWS Serverless Application Model (SAM)","text":"<p>The <code>Metrics</code> utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows <code>Metrics</code> to be aware of things like whether or not a given invocation had a cold start or not.</p> handler.tstemplate.yml   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\n// Metrics parameters fetched from the environment variables (see template.yaml tab)\nconst metrics = new Metrics();\nmetrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n\n// You can also pass the parameters in the constructor\n// const metrics = new Metrics({\n//   namespace: 'serverlessAirline',\n//   serviceName: 'orders'\n// });\n</code></pre>   <pre><code>Resources:\n  HelloWorldFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Runtime: nodejs16.x\n      Environment:\n      Variables:\n        POWERTOOLS_SERVICE_NAME: orders\n        POWERTOOLS_METRICS_NAMESPACE: serverlessAirline\n</code></pre>    <p>You can initialize Metrics anywhere in your code - It'll keep track of your aggregate metrics in memory.</p>"},{"location":"core/metrics/#creating-metrics","title":"Creating metrics","text":"<p>You can create metrics using the <code>addMetric</code> method, and you can create dimensions for all your aggregate metrics using the <code>addDimension</code> method.</p> MetricsMetrics with custom dimensions   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  metrics.publishStoredMetrics();\n};\n</code></pre>   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addDimension('environment', 'prod');\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  metrics.publishStoredMetrics();\n};\n</code></pre>     <p>Autocomplete Metric Units</p> <p>Use the <code>MetricUnit</code> enum to easily find a supported metric unit by CloudWatch. Alternatively, you can pass the value as a string if you already know them e.g. \"Count\".</p>   <p>Metrics overflow</p> <p>CloudWatch EMF supports a max of 100 metrics per batch. Metrics will automatically propagate all the metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience.</p>   <p>Do not create metrics or dimensions outside the handler</p> <p>Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behavior.</p>"},{"location":"core/metrics/#adding-high-resolution-metrics","title":"Adding high-resolution metrics","text":"<p>You can create high-resolution metrics passing <code>resolution</code> as parameter to <code>addMetric</code>. </p>  <p>When is it useful?</p> <p>High-resolution metrics are data with a granularity of one second and are very useful in several situations such as telemetry, time series, real-time incident management, and others.</p>  Metrics with high resolution   <pre><code>import { Metrics, MetricUnits, MetricResolution } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1, MetricResolution.High);\n};\n</code></pre>     <p>Autocomplete Metric Resolutions</p> <p>Use the <code>MetricResolution</code> type to easily find a supported metric resolution by CloudWatch. Alternatively, you can pass the allowed values of 1 or 60 as an integer.</p>"},{"location":"core/metrics/#adding-multi-value-metrics","title":"Adding multi-value metrics","text":"<p>You can call <code>addMetric()</code> with the same name multiple times. The values will be grouped together in an array.</p> addMetric() with the same nameExample CloudWatch Logs excerpt   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace:'serverlessAirline', serviceName:'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('performedActionA', MetricUnits.Count, 2);\n  // do something else...\n  metrics.addMetric('performedActionA', MetricUnits.Count, 1);\n};\n</code></pre>   <pre><code>{\n    \"performedActionA\": [\n        2,\n        1\n    ],\n    \"_aws\": {\n        \"Timestamp\": 1592234975665,\n        \"CloudWatchMetrics\": [\n            {\n            \"Namespace\": \"serverlessAirline\",\n            \"Dimensions\": [\n                [\n                \"service\"\n                ]\n            ],\n            \"Metrics\": [\n                {\n                \"Name\": \"performedActionA\",\n                \"Unit\": \"Count\"\n                }\n            ]\n            }\n        ]\n    },\n    \"service\": \"orders\"\n}\n</code></pre>"},{"location":"core/metrics/#adding-default-dimensions","title":"Adding default dimensions","text":"<p>You can add default dimensions to your metrics by passing them as parameters in 4 ways:  </p> <ul> <li>in the constructor</li> <li>in the Middy-compatible middleware</li> <li>using the <code>setDefaultDimensions</code> method</li> <li>in the decorator</li> </ul> constructorMiddy middlewaresetDefaultDimensions methodwith logMetrics decorator   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({\n  namespace: 'serverlessAirline', \n  serviceName: 'orders', \n  defaultDimensions: { 'environment': 'prod', 'foo': 'bar' } \n});\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n</code></pre>    <p>Using Middy for the first time?</p> <p>You can install Middy by running <code>npm i @middy/core</code>. Learn more about its usage and lifecycle in the official Middy documentation.</p>  <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n\n// Wrap the handler with middy\nexport const handler = middy(lambdaHandler)\n// Use the middleware by passing the Metrics instance as a parameter\n  .use(logMetrics(metrics, { defaultDimensions:{ 'environment': 'prod', 'foo': 'bar' } }));\n</code></pre>   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\nmetrics.setDefaultDimensions({ 'environment': 'prod', 'foo': 'bar' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n</code></pre>   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\nconst DEFAULT_DIMENSIONS = { 'environment': 'prod', 'foo': 'bar' };\n\nexport class Lambda implements LambdaInterface {\n  // Decorate your handler class method\n  @metrics.logMetrics({ defaultDimensions: DEFAULT_DIMENSIONS })\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>    <p>If you'd like to remove them at some point, you can use the <code>clearDefaultDimensions</code> method.</p>"},{"location":"core/metrics/#flushing-metrics","title":"Flushing metrics","text":"<p>As you finish adding all your metrics, you need to serialize and \"flush them\" by calling <code>publishStoredMetrics()</code>. This will print the metrics to standard output.</p> <p>You can flush metrics automatically using one of the following methods:  </p> <ul> <li>manually</li> <li>Middy-compatible middleware</li> <li>class decorator</li> </ul> <p>Using the Middy middleware or decorator will automatically validate, serialize, and flush all your metrics. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be thrown. If you do not use the middleware or decorator, you have to flush your metrics manually.</p>  <p>Metric validation</p> <p>If metrics are provided, and any of the following criteria are not met, a <code>RangeError</code> error will be thrown:</p> <ul> <li>Maximum of 29 dimensions</li> <li>Namespace is set only once (or none)</li> <li>Metric units must be supported by CloudWatch</li> </ul>"},{"location":"core/metrics/#middy-middleware","title":"Middy middleware","text":"<p>See below an example of how to automatically flush metrics with the Middy-compatible <code>logMetrics</code> middleware.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(logMetrics(metrics));\n</code></pre>   <pre><code>{\n    \"successfulBooking\": 1.0,\n    \"_aws\": {\n    \"Timestamp\": 1592234975665,\n    \"CloudWatchMetrics\": [\n        {\n        \"Namespace\": \"serverlessAirline\",\n        \"Dimensions\": [\n            [\n            \"service\"\n            ]\n        ],\n        \"Metrics\": [\n            {\n            \"Name\": \"successfulBooking\",\n            \"Unit\": \"Count\"\n            }\n        ]\n    },\n    \"service\": \"orders\"\n}\n</code></pre>"},{"location":"core/metrics/#using-the-class-decorator","title":"Using the class decorator","text":"<p>Info</p> <p>Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, check the middleware or manual method sections instead. See the official TypeScript documentation for more details.</p>  <p>The <code>logMetrics</code> decorator of the metrics utility can be used when your Lambda handler function is implemented as method of a Class.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nclass Lambda implements LambdaInterface {\n\n  @metrics.logMetrics()\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>   <pre><code>{\n    \"successfulBooking\": 1.0,\n    \"_aws\": {\n    \"Timestamp\": 1592234975665,\n    \"CloudWatchMetrics\": [\n        {\n        \"Namespace\": \"successfulBooking\",\n        \"Dimensions\": [\n            [\n            \"service\"\n            ]\n        ],\n        \"Metrics\": [\n            {\n            \"Name\": \"successfulBooking\",\n            \"Unit\": \"Count\"\n            }\n        ]\n    },\n    \"service\": \"orders\"\n}\n</code></pre>"},{"location":"core/metrics/#manually","title":"Manually","text":"<p>You can manually flush the metrics with <code>publishStoredMetrics</code> as follows:</p>  <p>Warning</p>  <p>Metrics, dimensions and namespace validation still applies.</p> handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 10);\n  metrics.publishStoredMetrics();\n};\n</code></pre>   <pre><code>{\n    \"successfulBooking\": 1.0,\n    \"_aws\": {\n    \"Timestamp\": 1592234975665,\n    \"CloudWatchMetrics\": [\n        {\n        \"Namespace\": \"successfulBooking\",\n        \"Dimensions\": [\n            [\n            \"service\"\n            ]\n        ],\n        \"Metrics\": [\n            {\n            \"Name\": \"successfulBooking\",\n            \"Unit\": \"Count\"\n            }\n        ]\n        }\n    ]\n    },\n    \"service\": \"orders\"\n}\n</code></pre>"},{"location":"core/metrics/#throwing-a-rangeerror-when-no-metrics-are-emitted","title":"Throwing a RangeError when no metrics are emitted","text":"<p>If you want to ensure that at least one metric is emitted before you flush them, you can use the <code>throwOnEmptyMetrics</code> parameter and pass it to the middleware or decorator:</p> handler.ts   <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(logMetrics(metrics, { throwOnEmptyMetrics: true }));\n</code></pre>"},{"location":"core/metrics/#capturing-a-cold-start-invocation-as-metric","title":"Capturing a cold start invocation as metric","text":"<p>You can optionally capture cold start metrics with the <code>logMetrics</code> middleware or decorator via the <code>captureColdStartMetric</code> param.</p> Middy MiddlewarelogMetrics decorator   <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(logMetrics(metrics, { captureColdStartMetric: true }));\n</code></pre>   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nexport class MyFunction implements LambdaInterface {\n\n  @metrics.logMetrics({ captureColdStartMetric: true })\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  }\n}\n</code></pre>    <p>If it's a cold start invocation, this feature will:</p> <ul> <li>Create a separate EMF blob solely containing a metric named <code>ColdStart</code></li> <li>Add the <code>function_name</code>, <code>service</code> and default dimensions</li> </ul> <p>This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions.</p>  <p>We do not emit 0 as a value for the ColdStart metric for cost-efficiency reasons. Let us know if you'd prefer a flag to override it.</p>"},{"location":"core/metrics/#advanced","title":"Advanced","text":""},{"location":"core/metrics/#adding-metadata","title":"Adding metadata","text":"<p>You can add high-cardinality data as part of your Metrics log with the <code>addMetadata</code> method. This is useful when you want to search highly contextual information along with your metrics in your logs.</p>  <p>Warning</p> <p>This will not be available during metrics visualization - Use dimensions for this purpose</p>  handler.tsExample CloudWatch Logs excerpt   <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addMetric('successfulBooking', MetricUnits.Count, 1);\n  metrics.addMetadata('bookingId', '7051cd10-6283-11ec-90d6-0242ac120003');\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(logMetrics(metrics));\n</code></pre>   <pre><code>{\n    \"successfulBooking\": 1.0,\n    \"_aws\": {\n    \"Timestamp\": 1592234975665,\n    \"CloudWatchMetrics\": [\n        {\n        \"Namespace\": \"serverlessAirline\",\n        \"Dimensions\": [\n            [\n            \"service\"\n            ]\n        ],\n        \"Metrics\": [\n            {\n            \"Namespace\": \"exampleApplication\",\n            \"Dimensions\": [\n                [\n                \"service\"\n                ]\n            ],\n            \"Metrics\": [\n                {\n                \"Name\": \"successfulBooking\",\n                \"Unit\": \"Count\"\n                }\n            ]\n            }\n        ]\n    },\n    \"service\": \"orders\",\n    \"bookingId\": \"7051cd10-6283-11ec-90d6-0242ac120003\"\n}\n</code></pre>"},{"location":"core/metrics/#single-metric-with-different-dimensions","title":"Single metric with different dimensions","text":"<p>CloudWatch EMF uses the same dimensions across all your metrics. Use <code>singleMetric</code> if you have a metric that should have different dimensions.</p>  <p>Info</p> <p>For cost-efficiency, this feature would be used sparsely since you pay for unique metric. Keep the following formula in mind:</p> <p>unique metric = (metric_name + dimension_name + dimension_value)</p>  Middy MiddlewarelogMetrics decorator   <pre><code>import { Metrics, MetricUnits, logMetrics } from '@aws-lambda-powertools/metrics';\nimport middy from '@middy/core';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  metrics.addDimension('metricUnit', 'milliseconds');\n  // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension:\n  metrics.addMetric('latency', MetricUnits.Milliseconds, 56);\n\n  const singleMetric = metrics.singleMetric();\n  // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension:\n  singleMetric.addDimension('metricType', 'business');\n  singleMetric.addMetric('orderSubmitted', MetricUnits.Count, 1);\n};\n\nexport const handler = middy(lambdaHandler)\n  .use(logMetrics(metrics));\n</code></pre>   <pre><code>import { Metrics, MetricUnits } from '@aws-lambda-powertools/metrics';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' });\n\nclass Lambda implements LambdaInterface {\n\n  @metrics.logMetrics()\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    metrics.addDimension('metricUnit', 'milliseconds');\n    // This metric will have the \"metricUnit\" dimension, and no \"metricType\" dimension:\n    metrics.addMetric('latency', MetricUnits.Milliseconds, 56);\n\n    const singleMetric = metrics.singleMetric();\n    // This metric will have the \"metricType\" dimension, and no \"metricUnit\" dimension:\n    singleMetric.addDimension('metricType', 'business');\n    singleMetric.addMetric('orderSubmitted', MetricUnits.Count, 1);\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code> within the class methods.</li> </ol>"},{"location":"core/tracer/","title":"Tracer","text":"<p>Tracer is an opinionated thin wrapper for AWS X-Ray SDK for Node.js.</p>"},{"location":"core/tracer/#key-features","title":"Key features","text":"<ul> <li>Auto-capturing cold start and service name as annotations, and responses or full exceptions as metadata.</li> <li>Automatically tracing HTTP(S) clients and generating segments for each request.</li> <li>Supporting tracing functions via decorators, middleware, and manual instrumentation.</li> <li>Supporting tracing AWS SDK v2 and v3 via AWS X-Ray SDK for Node.js.</li> <li>Auto-disable tracing when not running in the Lambda environment.</li> </ul>    Tracer showcase - Handler Annotations"},{"location":"core/tracer/#getting-started","title":"Getting started","text":""},{"location":"core/tracer/#installation","title":"Installation","text":"<p>Install the library in your project:</p> <pre><code>npm install @aws-lambda-powertools/tracer\n</code></pre>"},{"location":"core/tracer/#usage","title":"Usage","text":"<p>The <code>Tracer</code> utility must always be instantiated outside of the Lambda handler. In doing this, subsequent invocations processed by the same instance of your function can reuse these resources. This saves cost by reducing function run time. In addition, <code>Tracer</code> can track cold start and annotate the traces accordingly.</p> handler.ts   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event, _context): Promise&lt;void&gt; =&gt; {\n  tracer.getSegment();\n};\n</code></pre>"},{"location":"core/tracer/#utility-settings","title":"Utility settings","text":"<p>The library has three optional settings. You can set them as environment variables, or pass them in the constructor:</p>    Setting Description Environment variable Default Allowed Values Example Constructor parameter     Service name Sets an annotation with the name of the service across all traces <code>POWERTOOLS_SERVICE_NAME</code> <code>service_undefined</code> Any string <code>serverlessAirline</code> <code>serviceName</code>   Tracing enabled Enables or disables tracing. <code>POWERTOOLS_TRACE_ENABLED</code> <code>true</code> <code>true</code> or <code>false</code> <code>false</code> <code>enabled</code>   Capture HTTPs Requests Defines whether HTTPs requests will be traced or not <code>POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS</code> <code>true</code> <code>true</code> or <code>false</code> <code>false</code> <code>captureHTTPsRequests</code>   Capture Response Defines whether functions responses are serialized as metadata <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> <code>true</code> <code>true</code> or <code>false</code> <code>false</code> <code>captureResult</code>   Capture Errors Defines whether functions errors are serialized as metadata <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> <code>true</code> <code>true</code> or <code>false</code> <code>false</code> N/A     <p>Note</p> <p>Before your use this utility, your AWS Lambda function must have Active Tracing enabled as well as have permissions to send traces to AWS X-Ray</p>"},{"location":"core/tracer/#example-using-aws-serverless-application-model-sam","title":"Example using AWS Serverless Application Model (SAM)","text":"<p>The <code>Tracer</code> utility is instantiated outside of the Lambda handler. In doing this, the same instance can be used across multiple invocations inside the same execution environment. This allows <code>Tracer</code> to be aware of things like whether or not a given invocation had a cold start or not.</p> handler.tstemplate.yml   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\n// Tracer parameter fetched from the environment variables (see template.yaml tab)\nconst tracer = new Tracer();\ntracer.getSegment();\n\n// You can also pass the parameter in the constructor\n// const tracer = new Tracer({\n//     serviceName: 'serverlessAirline'\n// });\n</code></pre>   <pre><code>Resources:\n  HelloWorldFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Runtime: nodejs16.x\n      Tracing: Active\n      Environment:\n        Variables:\n          POWERTOOLS_SERVICE_NAME: serverlessAirline\n</code></pre>"},{"location":"core/tracer/#lambda-handler","title":"Lambda handler","text":"<p>You can quickly start by importing the <code>Tracer</code> class, initialize it outside the Lambda handler, and instrument your function.</p> Middy MiddlewareDecoratorManual    <p>Using Middy for the first time?</p> <p>You can install Middy by running <code>npm i @middy/core</code>. Learn more about its usage and lifecycle in the official Middy documentation.</p>  <pre><code>import { Tracer, captureLambdaHandler } from '@aws-lambda-powertools/tracer';\nimport middy from '@middy/core'; // (1)\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  tracer.putAnnotation('successfulBooking', true);\n};\n\n// Wrap the handler with middy\nexport const handler = middy(lambdaHandler)\n// Use the middleware by passing the Tracer instance as a parameter\n  .use(captureLambdaHandler(tracer));\n</code></pre> <ol> <li>Using Middy for the first time? You can install Middy by running <code>npm i @middy/core</code>.    Learn more about its usage and lifecycle in the official Middy documentation.</li> </ol>    <p>Info</p> <p>Decorators can only be attached to a class declaration, method, accessor, property, or parameter. Therefore, if you prefer to write your handler as a standard function rather than a Class method, use the middleware or the manual instrumentations instead. See the official TypeScript documentation for more details.</p>  <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nclass Lambda implements LambdaInterface {\n  // Decorate your handler class method\n  @tracer.captureLambdaHandler()\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    tracer.getSegment();\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass); // (1)\n</code></pre> <ol> <li>Binding your handler method allows your handler to access <code>this</code>.</li> </ol>   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;unknown&gt; =&gt; {\n  const segment = tracer.getSegment(); // This is the facade segment (the one that is created by AWS Lambda)\n  // Create subsegment for the function &amp; set it as active\n  const subsegment = segment.addNewSubsegment(`## ${process.env._HANDLER}`);\n  tracer.setSegment(subsegment);\n\n  // Annotate the subsegment with the cold start &amp; serviceName\n  tracer.annotateColdStart();\n  tracer.addServiceNameAnnotation();\n\n  try {\n\n    // Add the response as metadata \n    tracer.addResponseAsMetadata({}, process.env._HANDLER);\n  } catch (err) {\n    // Add the error as metadata\n    tracer.addErrorAsMetadata(err as Error);\n    throw err;\n  } finally {\n    // Close subsegment (the AWS Lambda one is closed automatically)\n    subsegment.close();\n    // Set back the facade segment as active again\n    tracer.setSegment(segment);\n  }\n\n  return {};\n};\n</code></pre>    <p>When using the <code>captureLambdaHandler</code> decorator or middleware, Tracer performs these additional tasks to ease operations:</p> <ul> <li>Handles the lifecycle of the subsegment</li> <li>Creates a <code>ColdStart</code> annotation to easily filter traces that have had an initialization overhead</li> <li>Creates a <code>Service</code> annotation to easily filter traces that have a specific service name</li> <li>Captures any response, or full exceptions generated by the handler, and include them as tracing metadata</li> </ul>"},{"location":"core/tracer/#annotations-metadata","title":"Annotations &amp; Metadata","text":"<p>Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions.</p> <p>Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object.</p> AnnotationsMetadata   <p>You can add annotations using <code>putAnnotation</code> method.</p> <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  tracer.putAnnotation('successfulBooking', true);\n};\n</code></pre>   <p>You can add metadata using <code>putMetadata</code> method.</p> <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n\n  tracer.putMetadata('paymentResponse', {\n    'foo': 'bar'\n  });\n};\n</code></pre>      Tracer showcase - Handler Metadata"},{"location":"core/tracer/#methods","title":"Methods","text":"<p>You can trace other Class methods using the <code>captureMethod</code> decorator or any arbitrary function using manual instrumentation.</p> DecoratorManual   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nclass Lambda implements LambdaInterface {\n  // Decorate your class method\n  @tracer.captureMethod() // (1)\n  public async getChargeId(): Promise&lt;string&gt; {\n    /* ... */\n    return 'foo bar';\n  }\n\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    await this.getChargeId();\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass); // (2)\n</code></pre> <ol> <li>You can set a custom name for the subsegment by passing <code>subSegmentName</code> to the decorator, like: <code>@tracer.captureMethod({ subSegmentName: '### myCustomMethod' })</code>.</li> <li>Binding your handler method allows your handler to access <code>this</code>.</li> </ol>   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nconst getChargeId = async (): Promise&lt;unknown&gt; =&gt; {\n  const parentSubsegment = tracer.getSegment(); // This is the subsegment currently active\n  // Create subsegment for the function &amp; set it as active\n  const subsegment = parentSubsegment.addNewSubsegment(`### chargeId`);\n  tracer.setSegment(subsegment);\n\n  let res;\n  try {\n    /* ... */\n    // Add the response as metadata\n    tracer.addResponseAsMetadata(res, 'chargeId');\n  } catch (err) {\n    // Add the error as metadata\n    tracer.addErrorAsMetadata(err as Error);\n    throw err;\n  }\n\n  // Close subsegment (the AWS Lambda one is closed automatically)\n  subsegment.close();\n  // Set the facade segment as active again\n  tracer.setSegment(parentSubsegment);\n\n  return res;\n};\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  await getChargeId();\n\n};\n</code></pre>"},{"location":"core/tracer/#patching-aws-sdk-clients","title":"Patching AWS SDK clients","text":"<p>Tracer can patch any AWS SDK clients and create traces when your application makes calls to AWS services.</p>  <p>Info</p> <p>The following snippet assumes you are using the AWS SDK v3 for JavaScript</p>  <p>You can patch any AWS SDK clients by calling the <code>captureAWSv3Client</code> method:</p> index.ts   <pre><code>import { SecretsManagerClient } from '@aws-sdk/client-secrets-manager';\nimport { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\ntracer.captureAWSv3Client(new SecretsManagerClient({}));\n</code></pre>     <p>Info</p> <p>The following two snippets assume you are using the AWS SDK v2 for JavaScript</p>  <p>You can patch all AWS SDK v2 clients by calling the <code>captureAWS</code> method:</p> index.ts   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\nimport AWS from 'aws-sdk';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\ntracer.captureAWS(AWS);\n</code></pre>    <p>If you're looking to shave a few microseconds, or milliseconds depending on your function memory configuration, you can patch only specific AWS SDK v2 clients using <code>captureAWSClient</code>:</p> index.ts   <pre><code>import { S3 } from 'aws-sdk';\nimport { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\ntracer.captureAWSClient(new S3());\n</code></pre>"},{"location":"core/tracer/#tracing-http-requests","title":"Tracing HTTP requests","text":"<p>When your function makes calls to HTTP APIs, Tracer automatically traces those calls and add the API to the service graph as a downstream service.</p> <p>You can opt-out from this feature by setting the <code>POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS=false</code> environment variable or by passing the <code>captureHTTPSRequests: false</code> option to the <code>Tracer</code> constructor.</p>  <p>Info</p> <p>The following snippet shows how to trace axios requests, but you can use any HTTP client library built on top of http or https. Support to 3rd party HTTP clients is provided on a best effort basis.</p>  index.tsExample Raw X-Ray Trace excerpt   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\nimport axios from 'axios'; // (1)\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  const { data } = await axios.get('https://httpbin.org/status/200');\n  tracer.addResponseAsMetadata(data);\n};\n</code></pre> <ol> <li>You can install the axios package using <code>npm i axios</code></li> </ol>   <pre><code>{\n    \"id\": \"22883fbc730e3a0b\",\n    \"name\": \"## index.handler\",\n    \"start_time\": 1647956168.22749,\n    \"end_time\": 1647956169.0679862,\n    \"subsegments\": [\n        {\n            \"id\": \"ab82ab2b7d525d8f\",\n            \"name\": \"httpbin.org\",\n            \"start_time\": 1647956168.407,\n            \"end_time\": 1647956168.945,\n            \"http\": {\n                \"request\": {\n                    \"url\": \"https://httpbin.org/status/200\",\n                    \"method\": \"GET\"\n                },\n                \"response\": {\n                    \"status\": 200,\n                    \"content_length\": 0\n                }\n            },\n            \"namespace\": \"remote\"\n        }\n    ]\n}\n</code></pre>"},{"location":"core/tracer/#advanced","title":"Advanced","text":""},{"location":"core/tracer/#disabling-response-auto-capture","title":"Disabling response auto-capture","text":"<p>Use <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE=false</code> environment variable to instruct Tracer not to serialize function responses as metadata.</p>  <p>This is commonly useful in three scenarios</p> <ol> <li>You might return sensitive information you don't want it to be added to your traces</li> <li>You might manipulate streaming objects that can be read only once; this prevents subsequent calls from being empty</li> <li>You might return more than 64K of data e.g., <code>message too long</code> error</li> </ol>  <p>Alternatively, use the <code>captureResponse: false</code> option in both <code>tracer.captureLambdaHandler()</code> and <code>tracer.captureMethod()</code> decorators, or use the same option in the Middy <code>captureLambdaHander</code> middleware to instruct Tracer not to serialize function responses as metadata.</p> method.tshandler.tsmiddy.ts   <pre><code>import { LambdaInterface } from '@aws-lambda-powertools/commons';\nimport { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nclass Lambda implements LambdaInterface {\n  @tracer.captureMethod({ captureResponse: false })\n  public async getChargeId(): Promise&lt;string&gt; {\n    /* ... */\n    return 'foo bar';\n  }\n\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    /* ... */\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass);\n</code></pre>   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\nimport { LambdaInterface } from '@aws-lambda-powertools/commons';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nclass Lambda implements LambdaInterface {\n  @tracer.captureLambdaHandler({ captureResponse: false })\n  public async handler(_event: unknown, _context: unknown): Promise&lt;void&gt; {\n    tracer.getSegment();\n  }\n}\n\nconst handlerClass = new Lambda();\nexport const handler = handlerClass.handler.bind(handlerClass);\n</code></pre>   <pre><code>import { Tracer, captureLambdaHandler } from '@aws-lambda-powertools/tracer';\nimport middy from '@middy/core';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nconst lambdaHandler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  /* ... */\n};\n\n// Wrap the handler with middy\nexport const handler = middy(lambdaHandler)\n// Use the middleware by passing the Tracer instance as a parameter,\n// but specify the captureResponse option as false.\n  .use(captureLambdaHandler(tracer, { captureResponse: false }));\n</code></pre>"},{"location":"core/tracer/#disabling-errors-auto-capture","title":"Disabling errors auto-capture","text":"<p>Use <code>POWERTOOLS_TRACER_CAPTURE_ERROR=false</code> environment variable to instruct Tracer not to serialize errors as metadata.</p>  <p>Commonly useful in one scenario</p> <ol> <li>You might return sensitive information from errors, stack traces you might not control</li> </ol>"},{"location":"core/tracer/#access-aws-x-ray-root-trace-id","title":"Access AWS X-Ray Root Trace ID","text":"<p>Tracer exposes a <code>getRootXrayTraceId()</code> method that allows you to retrieve the AWS X-Ray Root Trace ID corresponds to the current function execution.</p>  <p>This is commonly useful in two scenarios</p> <ol> <li>By including the root trace id in your response, consumers can use it to correlate requests</li> <li>You might want to surface the root trace id to your end users so that they can reference it while contacting customer service</li> </ol>  index.ts   <pre><code>import { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst tracer = new Tracer({ serviceName: 'serverlessAirline' });\n\nexport const handler = async (_event: unknown, _context: unknown): Promise&lt;void&gt; =&gt; {\n  try {\n\n  } catch (err) {\n    const rootTraceId = tracer.getRootXrayTraceId();\n\n    // Example of returning an error response\n    return {\n      statusCode: 500,\n      body: `Internal Error - Please contact support and quote the following id: ${rootTraceId}`,\n      headers: { '_X_AMZN_TRACE_ID': rootTraceId },\n    };\n  }\n};\n</code></pre>"},{"location":"core/tracer/#escape-hatch-mechanism","title":"Escape hatch mechanism","text":"<p>You can use <code>tracer.provider</code> attribute to access all methods provided by the AWS X-Ray SDK.</p> <p>This is useful when you need a feature available in X-Ray that is not available in the Tracer utility, for example SQL queries tracing, or a custom logger.</p> index.ts   <pre><code>import { Logger } from '@aws-lambda-powertools/logger';\nimport { Tracer } from '@aws-lambda-powertools/tracer';\n\nconst serviceName = 'serverlessAirline';\nconst logger = new Logger({ serviceName: serviceName });\nconst tracer = new Tracer({ serviceName: serviceName });\ntracer.provider.setLogger(logger);\n</code></pre>"},{"location":"core/tracer/#testing-your-code","title":"Testing your code","text":"<p>Tracer is disabled by default when not running in the AWS Lambda environment - This means no code changes or environment variables to be set.</p>"},{"location":"core/tracer/#tips","title":"Tips","text":"<ul> <li>Use annotations on key operations to slice and dice traces, create unique views, and create metrics from it via Trace Groups</li> <li>Use a namespace when adding metadata to group data more easily</li> <li>Annotations and metadata are added to the currently open subsegment. If you want them in a specific subsegment, create one via the escape hatch mechanism</li> </ul>"},{"location":"utilities/parameters/","title":"Parameters","text":"Warning <p>This page refers to an unreleased and upcoming utility. Please refer to this GitHub milestone for the latest updates.</p>  <p>The Parameters utility provides high-level functions to retrieve one or multiple parameter values from AWS Systems Manager Parameter Store, AWS Secrets Manager, AWS AppConfig, Amazon DynamoDB, or your own parameter store.</p>"},{"location":"utilities/parameters/#key-features","title":"Key features","text":"<ul> <li>Retrieve one or multiple parameters from the underlying provider</li> <li>Cache parameter values for a given amount of time (defaults to 5 seconds)</li> <li>Transform parameter values from JSON or base 64 encoded strings</li> <li>Bring Your Own Parameter Store Provider</li> </ul>"},{"location":"utilities/parameters/#getting-started","title":"Getting started","text":"<p>The Parameters Utility helps to retrieve parameters from the System Manager Parameter Store (SSM), secrets from the Secrets Manager, and application configuration from AppConfig. Additionally, the utility also offers support for a DynamoDB provider, enabling the retrieval of arbitrary parameters from specified tables.</p>"},{"location":"utilities/parameters/#installation","title":"Installation","text":"Note <p>This utility supports AWS SDK v3 for JavaScript only. This allows the utility to be modular, and you to install only the SDK packages you need and keep your bundle size small.</p>  <p>Depending on the provider you want to use, install the library and the corresponding AWS SDK package:</p> SSMProviderSecretsProviderAppConfigProviderDynamoDBProvider   <pre><code>npm install @aws-lambda-powertools/parameters @aws-sdk/client-ssm\n</code></pre>   <pre><code>npm install @aws-lambda-powertools/parameters @aws-sdk/client-secrets-manager\n</code></pre>   <pre><code>npm install @aws-lambda-powertools/parameters @aws-sdk/client-appconfigdata\n</code></pre>   <pre><code>npm install @aws-lambda-powertools/parameters @aws-sdk/client-dynamodb @aws-sdk/util-dynamodb\n</code></pre>     Tip <p>If you are using the <code>nodejs18.x</code> runtime, the AWS SDK for JavaScript v3 is already installed and you can install the utility only.</p>"},{"location":"utilities/parameters/#iam-permissions","title":"IAM Permissions","text":"<p>This utility requires additional permissions to work as expected.</p>  Note <p>Different parameter providers require different permissions.</p>     Provider Function/Method IAM Permission     SSM <code>getParameter</code>, <code>SSMProvider.get</code> <code>ssm:GetParameter</code>   SSM <code>getParameters</code>, <code>SSMProvider.getMultiple</code> <code>ssm:GetParametersByPath</code>   SSM <code>getParametersByName</code>, <code>SSMProvider.getParametersByName</code> <code>ssm:GetParameter</code> and <code>ssm:GetParameters</code>   SSM If using <code>decrypt: true</code> You must add an additional permission <code>kms:Decrypt</code>   Secrets <code>getSecret</code>, <code>SecretsProvider.get</code> <code>secretsmanager:GetSecretValue</code>   DynamoDB <code>DynamoDBProvider.get</code> <code>dynamodb:GetItem</code>   DynamoDB <code>DynamoDBProvider.getMultiple</code> <code>dynamodb:Query</code>   AppConfig <code>getAppConfig</code>, <code>AppConfigProvider.getAppConfig</code> <code>appconfig:GetLatestConfiguration</code> and <code>appconfig:StartConfigurationSession</code>"},{"location":"utilities/parameters/#fetching-parameters","title":"Fetching parameters","text":"<p>You can retrieve a single parameter using the <code>getParameter</code> high-level function.</p> Fetching a single parameter from SSM<pre><code>import { getParameter } from '@aws-lambda-powertools/parameters/ssm';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const parameter = await getParameter('/my/parameter');\n  console.log(parameter);\n};\n</code></pre> <p>For multiple parameters, you can use either:</p> <ul> <li><code>getParameters</code> to recursively fetch all parameters by path.</li> <li><code>getParametersByName</code> to fetch distinct parameters by their full name. It also accepts custom caching, transform, decrypt per parameter.</li> </ul> getParametersgetParametersByName   Fetching multiple parameters by path from SSM<pre><code>import { getParameters } from '@aws-lambda-powertools/parameters/ssm';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  /**\n   * Retrieve multiple parameters from a path prefix recursively.\n   * This returns an object with the parameter name as key\n   */ \n  const parameters = await getParameters('/my/path/prefix');\n  for (const [ key, value ] of Object.entries(parameters || {})) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>   Fetching multiple parameters by names from SSM<pre><code>import { getParametersByName } from '@aws-lambda-powertools/parameters/ssm';\nimport type {\n  SSMGetParametersByNameOptionsInterface\n} from '@aws-lambda-powertools/parameters/ssm';\n\nconst props: Record&lt;string, SSMGetParametersByNameOptionsInterface&gt; = {\n  '/develop/service/commons/telemetry/config': { maxAge: 300, transform: 'json' },\n  '/no_cache_param': { maxAge: 0 },\n  '/develop/service/payment/api/capture/url': {}, // When empty or undefined, it uses default values\n};\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // This returns an object with the parameter name as key\n  const parameters = await getParametersByName(props, { maxAge: 60 });\n  for (const [ key, value ] of Object.entries(parameters)) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>     <code>getParametersByName</code> supports graceful error handling <p>By default, the provider will throw a <code>GetParameterError</code> when any parameter fails to be fetched. You can override it by setting <code>throwOnError: false</code>.</p> <p>When disabled, instead the provider will take the following actions:</p> <ul> <li>Add failed parameter name in the <code>_errors</code> key, e.g., <code>{ _errors: [ '/param1', '/param2' ] }</code></li> <li>Keep only successful parameter names and their values in the response</li> <li>Throw <code>GetParameterError</code> if any of your parameters is named <code>_errors</code></li> </ul>  <pre><code>import { getParametersByName } from '@aws-lambda-powertools/parameters/ssm';\nimport type {\n  SSMGetParametersByNameOptionsInterface\n} from '@aws-lambda-powertools/parameters/ssm';\n\nconst props: Record&lt;string, SSMGetParametersByNameOptionsInterface&gt; = {\n  '/develop/service/commons/telemetry/config': { maxAge: 300, transform: 'json' },\n  '/this/param/does/not/exist': {}, // &lt;- Example of non-existent parameter\n};\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const {\n    _errors: errors,\n    ...parameters\n  } = await getParametersByName(props, { throwOnError: false });\n\n  // Handle gracefully, since `/this/param/does/not/exist` will only be available in `_errors`\n  if (errors &amp;&amp; errors.length) {\n    console.error(`Unable to retrieve parameters: ${errors.join(',')}`);\n  }\n\n  for (const [ key, value ] of Object.entries(parameters)) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>"},{"location":"utilities/parameters/#fetching-secrets","title":"Fetching secrets","text":"<p>You can fetch secrets stored in Secrets Manager using <code>getSecrets</code>.</p> Fetching secrets<pre><code>import { getSecret } from '@aws-lambda-powertools/parameters/secrets';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single secret\n  const secret = await getSecret('my-secret');\n  console.log(secret);\n};\n</code></pre>"},{"location":"utilities/parameters/#fetching-app-configurations","title":"Fetching app configurations","text":"<p>You can fetch application configurations in AWS AppConfig using <code>getAppConfig</code>.</p> <p>The following will retrieve the latest version and store it in the cache.</p> Fetching latest config from AppConfig<pre><code>import { getAppConfig } from '@aws-lambda-powertools/parameters/appconfig';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a configuration, latest version\n  const config = await getAppConfig('my-configuration', {\n    environment: 'my-env',\n    application: 'my-app'\n  });\n  console.log(config);\n};\n</code></pre>"},{"location":"utilities/parameters/#advanced","title":"Advanced","text":""},{"location":"utilities/parameters/#adjusting-cache-ttl","title":"Adjusting cache TTL","text":"Tip <p><code>maxAge</code> parameter is also available in high level functions like <code>getParameter</code>, <code>getSecret</code>, etc.</p>  <p>By default, the provider will cache parameters retrieved in-memory for 5 seconds.</p> <p>You can adjust how long values should be kept in cache by using the param <code>maxAge</code>, when using  <code>get()</code> or <code>getMultiple()</code> methods across all providers.</p> Caching parameters values in memory for longer than 5 seconds<pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\n\nconst parametersProvider = new SSMProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const parameter = await parametersProvider.get('/my/parameter', { maxAge: 60 }); // 1 minute\n  console.log(parameter);\n\n  // Retrieve multiple parameters from a path prefix\n  const parameters = await parametersProvider.getMultiple('/my/path/prefix', { maxAge: 120 }); // 2 minutes\n  for (const [ key, value ] of Object.entries(parameters || {})) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>"},{"location":"utilities/parameters/#always-fetching-the-latest","title":"Always fetching the latest","text":"<p>If you'd like to always ensure you fetch the latest parameter from the store regardless if already available in cache, use the <code>forceFetch</code> parameter.</p> Forcefully fetching the latest parameter whether TTL has expired or not<pre><code>import { getParameter } from '@aws-lambda-powertools/parameters/ssm';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const parameter = await getParameter('/my/parameter', { forceFetch: true });\n  console.log(parameter);\n};\n</code></pre>"},{"location":"utilities/parameters/#built-in-provider-class","title":"Built-in provider class","text":"<p>For greater flexibility such as configuring the underlying SDK client used by built-in providers, you can use their respective Provider Classes directly.</p>  Tip <p>This can be used to retrieve values from other regions, change the retry behavior, etc.</p>"},{"location":"utilities/parameters/#ssmprovider","title":"SSMProvider","text":"Example with SSMProvider for further extensibility<pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\nimport type { SSMClientConfig } from '@aws-sdk/client-ssm';\n\nconst clientConfig: SSMClientConfig = { region: 'us-east-1' };\nconst parametersProvider = new SSMProvider({ clientConfig });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const parameter = await parametersProvider.get('/my/parameter');\n  console.log(parameter);\n\n  // Retrieve multiple parameters from a path prefix\n  const parameters = await parametersProvider.getMultiple('/my/path/prefix');\n  for (const [ key, value ] of Object.entries(parameters || {})) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre> <p>The AWS Systems Manager Parameter Store provider supports two additional arguments for the <code>get()</code> and <code>getMultiple()</code> methods:</p>    Parameter Default Description     decrypt <code>false</code> Will automatically decrypt the parameter (see required IAM Permissions).   recursive <code>true</code> For <code>getMultiple()</code> only, will fetch all parameter values recursively based on a path prefix.    Example with get() and getMultiple()<pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\n\nconst parametersProvider = new SSMProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const decryptedValue = await parametersProvider.get('/my/encrypted/parameter', { decrypt: true });\n  console.log(decryptedValue);\n\n  const noRecursiveValues = await parametersProvider.getMultiple('/my/path/prefix', { recursive: false });\n  for (const [ key, value ] of Object.entries(noRecursiveValues || {})) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>"},{"location":"utilities/parameters/#secretsprovider","title":"SecretsProvider","text":"Example with SecretsProvider for further extensibility<pre><code>import { SecretsProvider } from '@aws-lambda-powertools/parameters/secrets';\nimport type { SecretsManagerClientConfig } from '@aws-sdk/client-secretsmanager';\n\nconst clientConfig: SecretsManagerClientConfig = { region: 'us-east-1' };\nconst secretsProvider = new SecretsProvider({ clientConfig });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single secret\n  const secret = await secretsProvider.get('my-secret');\n  console.log(secret);\n};\n</code></pre>"},{"location":"utilities/parameters/#appconfigprovider","title":"AppConfigProvider","text":"<p>The AWS AppConfig provider requires two arguments when initialized:</p>    Parameter Mandatory in constructor Alternative Description     application No <code>POWERTOOLS_SERVICE_NAME</code> env variable The application in which your config resides.   environment Yes (N/A) The environment that corresponds to your current config.    Example with AppConfigProvider for further extensibility<pre><code>import { AppConfigProvider } from '@aws-lambda-powertools/parameters/appconfig';\nimport type { AppConfigDataClientConfig } from '@aws-sdk/client-appconfigdata';\n\nconst clientConfig: AppConfigDataClientConfig = { region: 'us-east-1' };\nconst configsProvider = new AppConfigProvider({\n  application: 'my-app',\n  environment: 'my-env',\n  clientConfig,\n});\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a config\n  const config = await configsProvider.get('my-config');\n  console.log(config);\n};\n</code></pre>"},{"location":"utilities/parameters/#dynamodbprovider","title":"DynamoDBProvider","text":"<p>The DynamoDB Provider does not have any high-level functions and needs to know the name of the DynamoDB table containing the parameters.</p> <p>DynamoDB table structure for single parameters</p> <p>For single parameters, you must use <code>id</code> as the partition key for that table.</p>  Example <p>DynamoDB table with <code>id</code> partition key and <code>value</code> as attribute</p>     id value     my-parameter my-value    <p>With this table, <code>await dynamoDBProvider.get('my-param')</code> will return <code>my-value</code>.</p> handler.tsDynamoDB Local example   <pre><code>import { DynamoDBProvider } from '@aws-lambda-powertools/parameters/dynamodb';\n\nconst dynamoDBProvider = new DynamoDBProvider({ tableName: 'my-table' });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a value from DynamoDB\n  const value = await dynamoDBProvider.get('my-parameter');\n  console.log(value);\n};\n</code></pre>   <p>You can initialize the DynamoDB provider pointing to DynamoDB Local using the <code>endpoint</code> field in the <code>clientConfig</code> parameter:</p> <pre><code>import { DynamoDBProvider } from '@aws-lambda-powertools/parameters/dynamodb';\n\nconst dynamoDBProvider = new DynamoDBProvider({\n      tableName: 'my-table',\n      clientConfig: {\n        endpoint: 'http://localhost:8000'\n      },\n});\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a value from DynamoDB\n  const value = await dynamoDBProvider.get('my-parameter');\n  console.log(value);\n};\n</code></pre>    <p>DynamoDB table structure for multiple values parameters</p> <p>You can retrieve multiple parameters sharing the same <code>id</code> by having a sort key named <code>sk</code>.</p>  Example <p>DynamoDB table with <code>id</code> primary key, <code>sk</code> as sort key and <code>value</code> as attribute</p>     id sk value     my-hash-key param-a my-value-a   my-hash-key param-b my-value-b   my-hash-key param-c my-value-c    <p>With this table, <code>await dynamoDBProvider.getMultiple('my-hash-key')</code> will return a dictionary response in the shape of <code>sk:value</code>.</p> handler.tsvalues response object   <pre><code>import { DynamoDBProvider } from '@aws-lambda-powertools/parameters/dynamodb';\n\nconst dynamoDBProvider = new DynamoDBProvider({ tableName: 'my-table' });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  /**\n     * Retrieve multiple values by performing a Query on the DynamoDB table.\n     * This returns a dict with the sort key attribute as dict key.\n     */\n  const values = await dynamoDBProvider.getMultiple('my-hash-key');\n  for (const [ key, value ] of Object.entries(values || {})) {\n    // key: param-a\n    // value: my-value-a\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre>   <pre><code>{\n  \"param-a\": \"my-value-a\",\n  \"param-b\": \"my-value-b\",\n  \"param-c\": \"my-value-c\"\n}\n</code></pre>    <p>Customizing DynamoDBProvider</p> <p>DynamoDB provider can be customized at initialization to match your table structure:</p>    Parameter Mandatory Default Description     tableName Yes (N/A) Name of the DynamoDB table containing the parameter values.   keyAttr No <code>id</code> Hash key for the DynamoDB table.   sortAttr No <code>sk</code> Range key for the DynamoDB table. You don't need to set this if you don't use the <code>getMultiple()</code> method.   valueAttr No <code>value</code> Name of the attribute containing the parameter value.    Customizing DynamoDBProvider to suit your table design<pre><code>import { DynamoDBProvider } from '@aws-lambda-powertools/parameters/dynamodb';\n\nconst dynamoDBProvider = new DynamoDBProvider({\n  tableName:'my-table',\n  keyAttr:'key',\n  sortAttr:'sort',\n  valueAttr:'val'\n});\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const value = await dynamoDBProvider.get('my-parameter');\n  console.log(value);\n};\n</code></pre>"},{"location":"utilities/parameters/#deserializing-values-with-transform-parameter","title":"Deserializing values with transform parameter","text":"<p>For parameters stored in JSON or Base64 format, you can use the <code>transform</code> argument for deserialization.</p>  Info <p>The <code>transform</code> argument is available across all providers, including the high level functions.</p>  High level functionsProviders   <pre><code>import { getParameter } from '@aws-lambda-powertools/parameters/ssm';\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const valueFromJson = await getParameter('/my/json/parameter', { transform: 'json' });\n  console.log(valueFromJson);\n};\n</code></pre>   <pre><code>import { SecretsProvider } from '@aws-lambda-powertools/parameters/secrets';\n\nconst secretsProvider = new SecretsProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Transform a JSON string\n  const json = await secretsProvider.get('my-secret-json', { transform: 'json' });\n  console.log(json);\n\n  // Transform a Base64 encoded string (e.g. binary)\n  const binary = await secretsProvider.getMultiple('my-secret-binary', { transform: 'binary' });\n  console.log(binary);\n};\n</code></pre>"},{"location":"utilities/parameters/#partial-transform-failures-with-getmultiple","title":"Partial transform failures with <code>getMultiple()</code>","text":"<p>If you use <code>transform</code> with <code>getMultiple()</code>, you can have a single malformed parameter value. To prevent failing the entire request, the method will return an <code>undefined</code> value for the parameters that failed to transform.</p> <p>You can override this by setting the <code>throwOnTransformError</code> argument to <code>true</code>. If you do so, a single transform error will throw a <code>TransformParameterError</code> error.</p> <p>For example, if you have three parameters, /param/a, /param/b and /param/c, but /param/c is malformed:</p> Throwing TransformParameterError at first malformed parameter<pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\n\nconst parametersProvider = new SSMProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  /**\n   * This will display:\n   * /param/a: [some value]\n   * /param/b: [some value]\n   * /param/c: undefined\n   */\n  const parameters = await parametersProvider.getMultiple('/param', { transform: 'json' });\n  for (const [ key, value ] of Object.entries(parameters || {})) {\n    console.log(`${key}: ${value}`);\n  }\n\n  try {\n    // This will throw a TransformParameterError\n    const parameters2 = await parametersProvider.getMultiple('/param', {\n      transform: 'json',\n      throwOnTransformError: true\n    });\n    for (const [ key, value ] of Object.entries(parameters2 || {})) {\n      console.log(`${key}: ${value}`);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n};\n</code></pre>"},{"location":"utilities/parameters/#auto-transform-values-on-suffix","title":"Auto-transform values on suffix","text":"<p>If you use <code>transform</code> with <code>getMultiple()</code>, you might want to retrieve and transform parameters encoded in different formats.</p> <p>You can do this with a single request by using <code>transform: 'auto'</code>. This will instruct any provider to to infer its type based on the suffix and transform it accordingly.</p>  Info <p><code>transform: 'auto'</code> feature is available across all providers, including the high level functions.</p>  Deserializing parameter values based on their suffix<pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\n\nconst parametersProvider = new SSMProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const values = await parametersProvider.getMultiple('/param', { transform: 'auto' });\n  for (const [ key, value ] of Object.entries(values || {})) {\n    console.log(`${key}: ${value}`);\n  }\n};\n</code></pre> <p>For example, if you have three parameters: two with the following suffixes <code>.json</code> and <code>.binary</code> and one without any suffix:</p>    Parameter name Parameter value     /param/a [some encoded value]   /param/a.json [some encoded value]   /param/a.binary [some encoded value]    <p>The return of <code>await parametersProvider.getMultiple('/param', transform: 'auto');</code> call will be an object like:</p> <pre><code>{\n  \"a\": [some encoded value],\n  \"a.json\": [some decoded value],\n  \"b.binary\": [some decoded value]\n}\n</code></pre> <p>The two parameters with a suffix will be decoded, while the one without a suffix will be returned as is.</p>"},{"location":"utilities/parameters/#passing-additional-sdk-arguments","title":"Passing additional SDK arguments","text":"<p>You can use a special <code>sdkOptions</code> object argument to pass any supported option directly to the underlying SDK method.</p> Specify a VersionId for a secret<pre><code>import { SecretsProvider } from '@aws-lambda-powertools/parameters/secrets';\nimport type { GetSecretValueCommandInput } from '@aws-sdk/client-secrets-manager';\n\nconst secretsProvider = new SecretsProvider();\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const sdkOptions: Partial&lt;GetSecretValueCommandInput&gt; = {\n    VersionId: 'e62ec170-6b01-48c7-94f3-d7497851a8d2'\n  };\n  /**\n   * The 'VersionId' argument will be passed to the underlying\n   * `GetSecretValueCommand` call.\n   */\n  const secret = await secretsProvider.get('my-secret', { sdkOptions });\n  console.log(secret);\n};\n</code></pre> <p>Here is the mapping between this utility's functions and methods and the underlying SDK:</p>    Provider Function/Method Client name Function name     SSM Parameter Store <code>getParameter</code> <code>@aws-sdk/client-ssm</code> GetParameterCommand   SSM Parameter Store <code>getParameters</code> <code>@aws-sdk/client-ssm</code> GetParametersByPathCommand   SSM Parameter Store <code>SSMProvider.get</code> <code>@aws-sdk/client-ssm</code> GetParameterCommand   SSM Parameter Store <code>SSMProvider.getMultiple</code> <code>@aws-sdk/client-ssm</code> GetParametersByPathCommand   Secrets Manager <code>getSecret</code> <code>@aws-sdk/client-secrets-manager</code> GetSecretValueCommand   Secrets Manager <code>SecretsProvider.get</code> <code>@aws-sdk/client-secrets-manager</code> GetSecretValueCommand   AppConfig <code>AppConfigProvider.get</code> <code>@aws-sdk/client-appconfigdata</code> StartConfigurationSessionCommand &amp; GetLatestConfigurationCommand   AppConfig <code>getAppConfig</code> <code>@aws-sdk/client-appconfigdata</code> StartConfigurationSessionCommand &amp; GetLatestConfigurationCommand   DynamoDB <code>DynamoDBProvider.get</code> <code>@aws-sdk/client-dynamodb</code> GetItemCommand   DynamoDB <code>DynamoDBProvider.getMultiple</code> <code>@aws-sdk/client-dynamodb</code> QueryCommand"},{"location":"utilities/parameters/#bring-your-own-aws-sdk-v3-client","title":"Bring your own AWS SDK v3 client","text":"<p>You can use the <code>awsSdkV3Client</code> parameter via any of the available Provider Classes.</p>    Provider Client     SSMProvider <code>new SSMClient();</code>   SecretsProvider <code>new SecretsManagerClient();</code>   AppConfigProvider <code>new AppConfigDataClient();</code>   DynamoDBProvider <code>new DynamoDBClient();</code>     When is this useful? <p>Injecting a custom AWS SDK v3 client allows you to apply tracing or make unit/snapshot testing easier, including SDK customizations.</p>  SSMProviderSecretsProviderAppConfigProviderDynamoDBProvider   <pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\nimport { SSMClient } from '@aws-sdk/client-ssm';\n\n// construct your clients with any custom configuration\nconst ssmClient = new SSMClient({ region: 'us-east-1' });\n// pass the client to the provider\nconst parametersProvider = new SSMProvider({ awsSdkV3Client: ssmClient });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const parameter = await parametersProvider.get('/my/parameter');\n  console.log(parameter);\n};\n</code></pre>   <pre><code>import { SecretsProvider } from '@aws-lambda-powertools/parameters/secrets';\nimport { SecretsManagerClient } from '@aws-sdk/client-secrets-manager';\n\n// construct your clients with any custom configuration\nconst secretsManagerClient = new SecretsManagerClient({ region: 'us-east-1' });\n// pass the client to the provider\nconst secretsProvider = new SecretsProvider({ awsSdkV3Client: secretsManagerClient });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single secret\n  const secret = await secretsProvider.get('my-secret');\n  console.log(secret);\n};\n</code></pre>   <pre><code>import { AppConfigProvider } from '@aws-lambda-powertools/parameters/appconfig';\nimport { AppConfigDataClient } from '@aws-sdk/client-appconfigdata';\n\n// construct your clients with any custom configuration\nconst appConfigClient = new AppConfigDataClient({ region: 'us-east-1' });\n// pass the client to the provider\nconst configsProvider = new AppConfigProvider({ awsSdkV3Client: appConfigClient });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  const config = await configsProvider.get('my-config');\n  console.log(config);\n};\n</code></pre>   <pre><code>import { DynamoDBProvider } from '@aws-lambda-powertools/parameters/dynamodb';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\n// construct your clients with any custom configuration\nconst dynamoDBClient = new DynamoDBClient({ region: 'us-east-1' });\n// pass the client to the provider\nconst valuesProvider = new DynamoDBProvider({ awsSdkV3Client: dynamoDBClient });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single value\n  const value = await valuesProvider.get('my-value');\n  console.log(value);\n};\n</code></pre>"},{"location":"utilities/parameters/#customizing-aws-sdk-v3-configuration","title":"Customizing AWS SDK v3 configuration","text":"<p>The <code>clientConfig</code> parameter enables you to pass in a custom config object when constructing any of the built-in provider classes.</p>  Tip <p>You can use a custom session for retrieving parameters cross-account/region and for snapshot testing.</p> <p>When using VPC private endpoints, you can pass a custom client altogether. It's also useful for testing when injecting fake instances.</p>  <pre><code>import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';\nimport type { SSMClientConfig } from '@aws-sdk/client-ssm';\n\nconst clientConfig: SSMClientConfig = { region: 'us-east-1' };\nconst parametersProvider = new SSMProvider({ clientConfig });\n\nexport const handler = async (): Promise&lt;void&gt; =&gt; {\n  // Retrieve a single parameter\n  const value = await parametersProvider.get('/my/parameter');\n  console.log(value);\n};\n</code></pre>"}]}